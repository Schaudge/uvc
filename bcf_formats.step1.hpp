// This file is automatically generated by ./bcf_formats_generator1.out. All changes to this file will be lost after recompilation!!!
#ifndef bcf_formats_step1_INCLUDED
#define bcf_formats_step1_INCLUDED
#include<array>
#include<ostream>
#include<string>
#include<vector>
#include<assert.h>
namespace bcfrec {
static const unsigned int FILTER_NUM = 28;
enum FILTER_ENUM {
    noVar,
    upstreamDel,
    s50,
    Q10,
    Q20,
    Q30,
    Q40,
    Q50,
    Q60,
    aInsertSize,
    aBQXM,
    bcDup,
    cbDup,
    aAlignL,
    aAlignR,
    aPositionL,
    aPositionR,
    abPositionL,
    abPositionR,
    aStrand,
    c0Orientation,
    c2Orientation,
    c2AlignL,
    c2AlignR,
    c2PositionL,
    c2PositionR,
    c2StrictPosL,
    c2StrictPosR,
};
const char *const FILTER_IDS[] = {
    "noVar",
    "upstreamDel",
    "s50",
    "Q10",
    "Q20",
    "Q30",
    "Q40",
    "Q50",
    "Q60",
    "aInsertSize",
    "aBQXM",
    "bcDup",
    "cbDup",
    "aAlignL",
    "aAlignR",
    "aPositionL",
    "aPositionR",
    "abPositionL",
    "abPositionR",
    "aStrand",
    "c0Orientation",
    "c2Orientation",
    "c2AlignL",
    "c2AlignR",
    "c2PositionL",
    "c2PositionR",
    "c2StrictPosL",
    "c2StrictPosR",
};
const char *const FILTER_LINES[] = {
    "##FILTER=<ID=noVar,Description=\"Not a variant (for example, when REF and ALT are the same), but still included to get all statistics. \">",
    "##FILTER=<ID=upstreamDel,Description=\"Deletion extended from another upstream deletion. \">",
    "##FILTER=<ID=s50,Description=\"Less than 50% of samples have data. \">",
    "##FILTER=<ID=Q10,Description=\"Quality below 10 and no other filters. \">",
    "##FILTER=<ID=Q20,Description=\"Quality below 20 and no other filters. \">",
    "##FILTER=<ID=Q30,Description=\"Quality below 30 and no other filters. \">",
    "##FILTER=<ID=Q40,Description=\"Quality below 40 and no other filters. \">",
    "##FILTER=<ID=Q50,Description=\"Quality below 50 and no other filters. \">",
    "##FILTER=<ID=Q60,Description=\"Quality below 60 and no other filters. \">",
    "##FILTER=<ID=aInsertSize,Description=\"For FORMAT/FTS: Stranded insert bias, meaning the most-supported strand has abnormal insert size at either the left or right end. \">",
    "##FILTER=<ID=aBQXM,Description=\"For FORMAT/FTS: Passing-filter bias, meaning the variant allele is supported by reads with low base qualities at the variant site and/or with high number of mismatches relative to all alleles. \">",
    "##FILTER=<ID=bcDup,Description=\"For FORMAT/FTS: Duplication bias for less-than-expected amplification of variant reads, meaning the variant is under-amplified by PCR relative to all alleles. \">",
    "##FILTER=<ID=cbDup,Description=\"For FORMAT/FTS: Duplication bias for more-than-expected amplification of variant reads, meaning the variant is over-amplified by PCR relative to all alleles. \">",
    "##FILTER=<ID=aAlignL,Description=\"For FORMAT/FTS: Alignment bias on the left mapping coordinate of the sequenced segment relative to all alleles. \">",
    "##FILTER=<ID=aAlignR,Description=\"For FORMAT/FTS: Alignment bias on the right mapping coordinate of the sequenced segment relative to all alleles. \">",
    "##FILTER=<ID=aPositionL,Description=\"For FORMAT/FTS: Position bias on the left mapping coordinate of the sequenced segment relative to all alleles. \">",
    "##FILTER=<ID=aPositionR,Description=\"For FORMAT/FTS: Position bias on the right mapping coordinate of the sequenced segment relative to all alleles. \">",
    "##FILTER=<ID=abPositionL,Description=\"For FORMAT/FTS: Position bias on the left mapping coordinate of the insert relative to all alleles. \">",
    "##FILTER=<ID=abPositionR,Description=\"For FORMAT/FTS: Position bias on the right mapping coordinate of the insert relative to all alleles. \">",
    "##FILTER=<ID=aStrand,Description=\"For FORMAT/FTS: Strand bias relative to all alleles. \">",
    "##FILTER=<ID=c0Orientation,Description=\"For FORMAT/FTS: Read-orientation bias using de-duplicated reads families passing the base-quality threshold for generating UMI-barcode families relative to all alleles. \">",
    "##FILTER=<ID=c2Orientation,Description=\"For FORMAT/FTS: Read-orientation bias using tier-2 UMI-barcode families relative to all alleles. \">",
    "##FILTER=<ID=c2AlignL,Description=\"For FORMAT/FTS: Alignment bias on the left mapping coordinate of the tier-2 single-strand consensus sequence (SSCS) relative to all alleles. \">",
    "##FILTER=<ID=c2AlignR,Description=\"For FORMAT/FTS: Alignment bias on the right mapping coordinate of the tier-2 single-strand consensus sequence (SSCS) relative to all alleles. \">",
    "##FILTER=<ID=c2PositionL,Description=\"For FORMAT/FTS: Position bias on the left mapping coordinate of the tier-2 single-strand consensus sequence (SSCS) relative to all alleles. \">",
    "##FILTER=<ID=c2PositionR,Description=\"For FORMAT/FTS: Position bias on the right mapping coordinate of the tier-2 single-strand consensus sequence (SSCS) relative to all alleles. \">",
    "##FILTER=<ID=c2StrictPosL,Description=\"For FORMAT/FTS: Strictly defined position bias (which has zero prior probability of not having bias) on the left mapping coordinate of the tier-2 single-strand consensus sequence (SSCS) relative to all alleles. \">",
    "##FILTER=<ID=c2StrictPosR,Description=\"For FORMAT/FTS: Strictly defined position bias (which has zero prior probability of not having bias) on the right mapping coordinate of the tier-2 single-strand consensus sequence (SSCS) relative to all alleles. \">",
};
static const unsigned int FORMAT_NUM = 258;
enum FORMAT_ENUM {
    GT,
    GQ,
    HQ,
    FT,
    FTS,
    _A_,
    DP,
    AD,
    bDP,
    bAD,
    c2DP,
    c2AD,
    _Aa,
    APDP,
    APXM,
    _Ab,
    APLRID,
    APLRI,
    APLRP,
    _Ac,
    ALRPxT,
    ALRIT,
    ALRIt,
    ALRPt,
    ALRBt,
    _AQ,
    aMQs,
    AMQs,
    a1BQf,
    A1BQf,
    a1BQr,
    A1BQr,
    _ADPf,
    aDPff,
    ADPff,
    aDPfr,
    ADPfr,
    _ADPr,
    aDPrf,
    ADPrf,
    aDPrr,
    ADPrr,
    _ALP,
    aLP1,
    ALP1,
    aLP2,
    ALP2,
    aLPL,
    ALPL,
    _ARP,
    aRP1,
    ARP1,
    aRP2,
    ARP2,
    aRPL,
    ARPL,
    _ALB,
    aLB1,
    aLB2,
    ALB2,
    aLBL,
    ALBL,
    _ARB,
    aRB1,
    aRB2,
    ARB2,
    aRBL,
    ARBL,
    _ALI,
    aLI1,
    aLI2,
    ALI2,
    aLIr,
    ALIr,
    _ARI,
    aRI1,
    aRI2,
    ARI2,
    aRIf,
    ARIf,
    _AX,
    aBQ2,
    ABQ2,
    aPF2,
    APF2,
    aP1,
    AP1,
    aP2,
    AP2,
    _Ax,
    aPF1,
    aLIT,
    aRIT,
    aP3,
    aNC,
    _BDP,
    bDPf,
    bDPr,
    BDPb,
    BDPd,
    bTAf,
    bTAr,
    BTAb,
    bTBf,
    bTBr,
    BTBb,
    _CDP1,
    cDP1f,
    cDP1r,
    CDP1b,
    CDP1d,
    cDP12f,
    cDP12r,
    CDP12b,
    _CDP2,
    cDP2f,
    cDP2r,
    CDP2b,
    CDP2d,
    c2BQ2,
    C2BQ2,
    c2LP0,
    C2LP0,
    c2RP0,
    C2RP0,
    _C2XP,
    c2LP1,
    c2LP2,
    C2LP2,
    c2RP1,
    c2RP2,
    C2RP2,
    c2LPL,
    C2LPL,
    c2RPL,
    C2RPL,
    _C2XB,
    c2LB1,
    c2LB2,
    C2LB2,
    c2RB1,
    c2RB2,
    C2RB2,
    c2LBL,
    C2LBL,
    c2RBL,
    C2RBL,
    _CDPx,
    cDP3f,
    cDP3r,
    CDP3b,
    cDP21f,
    cDP21r,
    CDP21b,
    _cDPMm,
    cDPMf,
    cDPMr,
    CDPMb,
    cDPmf,
    cDPmr,
    CDPmb,
    CDPDb,
    cDPDf,
    cDPDr,
    _DDP,
    DDP1,
    dDP1,
    DDP2,
    dDP2,
    _ea,
    aBQ,
    a2BQf,
    a2BQr,
    a2XM2,
    a2BM2,
    aBQQ,
    _eb,
    bMQ,
    aAaMQ,
    bNMQ,
    bNMa,
    bNMb,
    bMQQ,
    _eB,
    bIAQb,
    bIADb,
    bIDQb,
    _eC,
    cIAQf,
    cIADf,
    cIDQf,
    cIAQr,
    cIADr,
    cIDQr,
    _eE,
    bIAQ,
    cIAQ,
    bTINQ,
    cTINQ,
    _eQ1,
    cPCQ1,
    cPLQ1,
    cVQ1,
    gVQ1,
    _eQ2,
    cPCQ2,
    cPLQ2,
    cVQ2,
    cMmQ,
    dVQinc,
    _CDP1vx,
    cDP1v,
    CDP1v,
    cDP1w,
    CDP1w,
    cDP1x,
    CDP1x,
    _CDP2vx,
    cDP2v,
    CDP2v,
    cDP2w,
    CDP2w,
    cDP2x,
    CDP2x,
    _f1,
    CONTQ,
    nPF,
    nNFA,
    nAFA,
    nBCFA,
    _g1,
    VTI,
    VTD,
    cVQ1M,
    cVQ2M,
    cVQAM,
    cVQSM,
    _g2,
    gapNf,
    gapNr,
    gapSeq,
    gapbAD1,
    gapcAD1,
    gc2AD,
    gc2dAD,
    _g3,
    bDPa,
    cDP0a,
    gapSa,
    _h1,
    bHap,
    cHap,
    c2Hap,
    _i1,
    vHGQ,
    vAC,
    vNLODQ,
    note,
};
const char *const FORMAT_STRING_PER_REC = "GT:GQ:HQ:FT:FTS:_A_:DP:AD:bDP:bAD:c2DP:c2AD:_Aa:APDP:APXM:_Ab:APLRID:APLRI:APLRP:_Ac:ALRPxT:ALRIT:ALRIt:ALRPt:ALRBt:_AQ:aMQs:AMQs:a1BQf:A1BQf:a1BQr:A1BQr:_ADPf:aDPff:ADPff:aDPfr:ADPfr:_ADPr:aDPrf:ADPrf:aDPrr:ADPrr:_ALP:aLP1:ALP1:aLP2:ALP2:aLPL:ALPL:_ARP:aRP1:ARP1:aRP2:ARP2:aRPL:ARPL:_ALB:aLB1:aLB2:ALB2:aLBL:ALBL:_ARB:aRB1:aRB2:ARB2:aRBL:ARBL:_ALI:aLI1:aLI2:ALI2:aLIr:ALIr:_ARI:aRI1:aRI2:ARI2:aRIf:ARIf:_AX:aBQ2:ABQ2:aPF2:APF2:aP1:AP1:aP2:AP2:_Ax:aPF1:aLIT:aRIT:aP3:aNC:_BDP:bDPf:bDPr:BDPb:BDPd:bTAf:bTAr:BTAb:bTBf:bTBr:BTBb:_CDP1:cDP1f:cDP1r:CDP1b:CDP1d:cDP12f:cDP12r:CDP12b:_CDP2:cDP2f:cDP2r:CDP2b:CDP2d:c2BQ2:C2BQ2:c2LP0:C2LP0:c2RP0:C2RP0:_C2XP:c2LP1:c2LP2:c2RP1:c2RP2:c2LPL:c2RPL:_C2XB:c2LB1:c2LB2:c2RB1:c2RB2:c2LBL:c2RBL:_CDPx:cDP3f:cDP3r:CDP3b:cDP21f:cDP21r:CDP21b:_cDPMm:cDPMf:cDPMr:CDPMb:cDPmf:cDPmr:CDPmb:CDPDb:cDPDf:cDPDr:_DDP:DDP1:dDP1:DDP2:dDP2:_ea:aBQ:a2BQf:a2BQr:a2XM2:a2BM2:aBQQ:_eb:bMQ:aAaMQ:bNMQ:bNMa:bNMb:bMQQ:_eB:bIAQb:bIADb:bIDQb:_eC:cIAQf:cIADf:cIDQf:cIAQr:cIADr:cIDQr:_eE:bIAQ:cIAQ:bTINQ:cTINQ:_eQ1:cPCQ1:cPLQ1:cVQ1:gVQ1:_eQ2:cPCQ2:cPLQ2:cVQ2:cMmQ:dVQinc:_CDP1vx:cDP1v:CDP1v:cDP1w:CDP1w:cDP1x:CDP1x:_CDP2vx:cDP2v:CDP2v:cDP2w:CDP2w:cDP2x:CDP2x:_f1:CONTQ:nPF:nNFA:nAFA:nBCFA:_g1:VTI:VTD:cVQ1M:cVQ2M:cVQAM:cVQSM:_g2:gapNf:gapNr:gapSeq:gapbAD1:gapcAD1:gc2AD:gc2dAD:_g3:bDPa:cDP0a:gapSa:_h1:bHap:cHap:c2Hap:_i1:vHGQ:vAC:vNLODQ:note";
const char *const FORMAT_STRING_PER_REC_WITHOUT_SSCS = "GT:GQ:HQ:FT:FTS:_A_:DP:AD:bDP:bAD:c2DP:c2AD:_Aa:APDP:APXM:_Ab:APLRID:APLRI:APLRP:_Ac:ALRPxT:ALRIT:ALRIt:ALRPt:ALRBt:_AQ:aMQs:AMQs:a1BQf:A1BQf:a1BQr:A1BQr:_ADPf:aDPff:ADPff:aDPfr:ADPfr:_ADPr:aDPrf:ADPrf:aDPrr:ADPrr:_ALP:aLP1:ALP1:aLP2:ALP2:aLPL:ALPL:_ARP:aRP1:ARP1:aRP2:ARP2:aRPL:ARPL:_ALB:aLB1:aLB2:ALB2:aLBL:ALBL:_ARB:aRB1:aRB2:ARB2:aRBL:ARBL:_ALI:aLI1:aLI2:ALI2:aLIr:ALIr:_ARI:aRI1:aRI2:ARI2:aRIf:ARIf:_AX:aBQ2:ABQ2:aPF2:APF2:aP1:AP1:aP2:AP2:_Ax:aPF1:aLIT:aRIT:aP3:aNC:_BDP:bDPf:bDPr:BDPb:BDPd:bTAf:bTAr:BTAb:bTBf:bTBr:BTBb:_CDP1:cDP1f:cDP1r:CDP1b:CDP1d:cDP12f:cDP12r:CDP12b:_CDP2:cDP2f:cDP2r:CDP2b:CDP2d:CDPDb:cDPDf:cDPDr:_DDP:DDP1:dDP1:DDP2:dDP2:_ea:aBQ:a2BQf:a2BQr:a2XM2:a2BM2:aBQQ:_eb:bMQ:aAaMQ:bNMQ:bNMa:bNMb:bMQQ:_eB:bIAQb:bIADb:bIDQb:_eC:cIAQf:cIADf:cIDQf:cIAQr:cIADr:cIDQr:_eE:bIAQ:cIAQ:bTINQ:cTINQ:_eQ1:cPCQ1:cPLQ1:cVQ1:gVQ1:_eQ2:cPCQ2:cPLQ2:cVQ2:cMmQ:dVQinc:_CDP1vx:cDP1v:CDP1v:cDP1w:CDP1w:cDP1x:CDP1x:_CDP2vx:cDP2v:CDP2v:cDP2w:CDP2w:cDP2x:CDP2x:_f1:CONTQ:nPF:nNFA:nAFA:nBCFA:_g1:VTI:VTD:cVQ1M:cVQ2M:cVQAM:cVQSM:_g2:gapNf:gapNr:gapSeq:gapbAD1:gapcAD1:gc2AD:gc2dAD:_g3:bDPa:cDP0a:gapSa:_h1:bHap:cHap:c2Hap:_i1:vHGQ:vAC:vNLODQ:note";
const char *const FORMAT_IDS[] = {
    "GT",
    "GQ",
    "HQ",
    "FT",
    "FTS",
    "_A_",
    "DP",
    "AD",
    "bDP",
    "bAD",
    "c2DP",
    "c2AD",
    "_Aa",
    "APDP",
    "APXM",
    "_Ab",
    "APLRID",
    "APLRI",
    "APLRP",
    "_Ac",
    "ALRPxT",
    "ALRIT",
    "ALRIt",
    "ALRPt",
    "ALRBt",
    "_AQ",
    "aMQs",
    "AMQs",
    "a1BQf",
    "A1BQf",
    "a1BQr",
    "A1BQr",
    "_ADPf",
    "aDPff",
    "ADPff",
    "aDPfr",
    "ADPfr",
    "_ADPr",
    "aDPrf",
    "ADPrf",
    "aDPrr",
    "ADPrr",
    "_ALP",
    "aLP1",
    "ALP1",
    "aLP2",
    "ALP2",
    "aLPL",
    "ALPL",
    "_ARP",
    "aRP1",
    "ARP1",
    "aRP2",
    "ARP2",
    "aRPL",
    "ARPL",
    "_ALB",
    "aLB1",
    "aLB2",
    "ALB2",
    "aLBL",
    "ALBL",
    "_ARB",
    "aRB1",
    "aRB2",
    "ARB2",
    "aRBL",
    "ARBL",
    "_ALI",
    "aLI1",
    "aLI2",
    "ALI2",
    "aLIr",
    "ALIr",
    "_ARI",
    "aRI1",
    "aRI2",
    "ARI2",
    "aRIf",
    "ARIf",
    "_AX",
    "aBQ2",
    "ABQ2",
    "aPF2",
    "APF2",
    "aP1",
    "AP1",
    "aP2",
    "AP2",
    "_Ax",
    "aPF1",
    "aLIT",
    "aRIT",
    "aP3",
    "aNC",
    "_BDP",
    "bDPf",
    "bDPr",
    "BDPb",
    "BDPd",
    "bTAf",
    "bTAr",
    "BTAb",
    "bTBf",
    "bTBr",
    "BTBb",
    "_CDP1",
    "cDP1f",
    "cDP1r",
    "CDP1b",
    "CDP1d",
    "cDP12f",
    "cDP12r",
    "CDP12b",
    "_CDP2",
    "cDP2f",
    "cDP2r",
    "CDP2b",
    "CDP2d",
    "c2BQ2",
    "C2BQ2",
    "c2LP0",
    "C2LP0",
    "c2RP0",
    "C2RP0",
    "_C2XP",
    "c2LP1",
    "c2LP2",
    "C2LP2",
    "c2RP1",
    "c2RP2",
    "C2RP2",
    "c2LPL",
    "C2LPL",
    "c2RPL",
    "C2RPL",
    "_C2XB",
    "c2LB1",
    "c2LB2",
    "C2LB2",
    "c2RB1",
    "c2RB2",
    "C2RB2",
    "c2LBL",
    "C2LBL",
    "c2RBL",
    "C2RBL",
    "_CDPx",
    "cDP3f",
    "cDP3r",
    "CDP3b",
    "cDP21f",
    "cDP21r",
    "CDP21b",
    "_cDPMm",
    "cDPMf",
    "cDPMr",
    "CDPMb",
    "cDPmf",
    "cDPmr",
    "CDPmb",
    "CDPDb",
    "cDPDf",
    "cDPDr",
    "_DDP",
    "DDP1",
    "dDP1",
    "DDP2",
    "dDP2",
    "_ea",
    "aBQ",
    "a2BQf",
    "a2BQr",
    "a2XM2",
    "a2BM2",
    "aBQQ",
    "_eb",
    "bMQ",
    "aAaMQ",
    "bNMQ",
    "bNMa",
    "bNMb",
    "bMQQ",
    "_eB",
    "bIAQb",
    "bIADb",
    "bIDQb",
    "_eC",
    "cIAQf",
    "cIADf",
    "cIDQf",
    "cIAQr",
    "cIADr",
    "cIDQr",
    "_eE",
    "bIAQ",
    "cIAQ",
    "bTINQ",
    "cTINQ",
    "_eQ1",
    "cPCQ1",
    "cPLQ1",
    "cVQ1",
    "gVQ1",
    "_eQ2",
    "cPCQ2",
    "cPLQ2",
    "cVQ2",
    "cMmQ",
    "dVQinc",
    "_CDP1vx",
    "cDP1v",
    "CDP1v",
    "cDP1w",
    "CDP1w",
    "cDP1x",
    "CDP1x",
    "_CDP2vx",
    "cDP2v",
    "CDP2v",
    "cDP2w",
    "CDP2w",
    "cDP2x",
    "CDP2x",
    "_f1",
    "CONTQ",
    "nPF",
    "nNFA",
    "nAFA",
    "nBCFA",
    "_g1",
    "VTI",
    "VTD",
    "cVQ1M",
    "cVQ2M",
    "cVQAM",
    "cVQSM",
    "_g2",
    "gapNf",
    "gapNr",
    "gapSeq",
    "gapbAD1",
    "gapcAD1",
    "gc2AD",
    "gc2dAD",
    "_g3",
    "bDPa",
    "cDP0a",
    "gapSa",
    "_h1",
    "bHap",
    "cHap",
    "c2Hap",
    "_i1",
    "vHGQ",
    "vAC",
    "vNLODQ",
    "note",
};
struct BcfFormat {
    bool enable_tier2_consensus_format_tags = false;
    std::string GT = "";
    int32_t GQ = 0;
    std::array <int32_t, 2>HQ = {{0}};
    std::string FT = "";
    std::vector<std::string>FTS;
    bool _A_ = false;
    int32_t DP = 0;
    std::vector<int32_t>AD;
    int32_t bDP = 0;
    std::vector<int32_t>bAD;
    int32_t c2DP = 0;
    std::vector<int32_t>c2AD;
    bool _Aa = false;
    std::array <int32_t, 12>APDP = {{0}};
    std::array <int64_t, 8>APXM = {{0}};
    bool _Ab = false;
    std::array <int64_t, 4>APLRID = {{0}};
    std::array <int64_t, 4>APLRI = {{0}};
    std::array <int32_t, 4>APLRP = {{0}};
    bool _Ac = false;
    std::array <int32_t, 2>ALRPxT = {{0}};
    std::array <int32_t, 4>ALRIT = {{0}};
    std::array <int32_t, 4>ALRIt = {{0}};
    std::array <int32_t, 4>ALRPt = {{0}};
    std::array <int32_t, 4>ALRBt = {{0}};
    bool _AQ = false;
    std::vector<int32_t>aMQs;
    std::array <int32_t, 2>AMQs = {{0}};
    std::vector<int32_t>a1BQf;
    std::array <int32_t, 2>A1BQf = {{0}};
    std::vector<int32_t>a1BQr;
    std::array <int32_t, 2>A1BQr = {{0}};
    bool _ADPf = false;
    std::vector<int32_t>aDPff;
    std::array <int32_t, 2>ADPff = {{0}};
    std::vector<int32_t>aDPfr;
    std::array <int32_t, 2>ADPfr = {{0}};
    bool _ADPr = false;
    std::vector<int32_t>aDPrf;
    std::array <int32_t, 2>ADPrf = {{0}};
    std::vector<int32_t>aDPrr;
    std::array <int32_t, 2>ADPrr = {{0}};
    bool _ALP = false;
    std::vector<int32_t>aLP1;
    std::array <int32_t, 2>ALP1 = {{0}};
    std::vector<int32_t>aLP2;
    std::array <int32_t, 2>ALP2 = {{0}};
    std::vector<int64_t>aLPL;
    std::array <int64_t, 2>ALPL = {{0}};
    bool _ARP = false;
    std::vector<int32_t>aRP1;
    std::array <int32_t, 2>ARP1 = {{0}};
    std::vector<int32_t>aRP2;
    std::array <int32_t, 2>ARP2 = {{0}};
    std::vector<int64_t>aRPL;
    std::array <int64_t, 2>ARPL = {{0}};
    bool _ALB = false;
    std::vector<int32_t>aLB1;
    std::vector<int32_t>aLB2;
    std::array <int32_t, 2>ALB2 = {{0}};
    std::vector<int64_t>aLBL;
    std::array <int64_t, 2>ALBL = {{0}};
    bool _ARB = false;
    std::vector<int32_t>aRB1;
    std::vector<int32_t>aRB2;
    std::array <int32_t, 2>ARB2 = {{0}};
    std::vector<int64_t>aRBL;
    std::array <int64_t, 2>ARBL = {{0}};
    bool _ALI = false;
    std::vector<int32_t>aLI1;
    std::vector<int32_t>aLI2;
    std::array <int32_t, 2>ALI2 = {{0}};
    std::vector<int32_t>aLIr;
    std::array <int32_t, 2>ALIr = {{0}};
    bool _ARI = false;
    std::vector<int32_t>aRI1;
    std::vector<int32_t>aRI2;
    std::array <int32_t, 2>ARI2 = {{0}};
    std::vector<int32_t>aRIf;
    std::array <int32_t, 2>ARIf = {{0}};
    bool _AX = false;
    std::vector<int32_t>aBQ2;
    std::array <int32_t, 2>ABQ2 = {{0}};
    std::vector<int32_t>aPF2;
    std::array <int32_t, 2>APF2 = {{0}};
    std::vector<int32_t>aP1;
    std::array <int32_t, 2>AP1 = {{0}};
    std::vector<int32_t>aP2;
    std::array <int32_t, 2>AP2 = {{0}};
    bool _Ax = false;
    std::vector<int32_t>aPF1;
    std::vector<int64_t>aLIT;
    std::vector<int64_t>aRIT;
    std::vector<int32_t>aP3;
    std::vector<int32_t>aNC;
    bool _BDP = false;
    std::vector<int32_t>bDPf;
    std::vector<int32_t>bDPr;
    std::array <int32_t, 2>BDPb = {{0}};
    std::array <int32_t, 2>BDPd = {{0}};
    std::vector<int32_t>bTAf;
    std::vector<int32_t>bTAr;
    std::array <int32_t, 2>BTAb = {{0}};
    std::vector<int32_t>bTBf;
    std::vector<int32_t>bTBr;
    std::array <int32_t, 2>BTBb = {{0}};
    bool _CDP1 = false;
    std::vector<int32_t>cDP1f;
    std::vector<int32_t>cDP1r;
    std::array <int32_t, 2>CDP1b = {{0}};
    std::array <int32_t, 2>CDP1d = {{0}};
    std::vector<int32_t>cDP12f;
    std::vector<int32_t>cDP12r;
    std::array <int32_t, 2>CDP12b = {{0}};
    bool _CDP2 = false;
    std::vector<int32_t>cDP2f;
    std::vector<int32_t>cDP2r;
    std::array <int32_t, 2>CDP2b = {{0}};
    std::array <int32_t, 2>CDP2d = {{0}};
    std::vector<int32_t>c2BQ2;
    std::array <int32_t, 2>C2BQ2 = {{0}};
    std::vector<int32_t>c2LP0;
    std::array <int32_t, 2>C2LP0 = {{0}};
    std::vector<int32_t>c2RP0;
    std::array <int32_t, 2>C2RP0 = {{0}};
    bool _C2XP = false;
    std::vector<int32_t>c2LP1;
    std::vector<int32_t>c2LP2;
    std::array <int32_t, 2>C2LP2 = {{0}};
    std::vector<int32_t>c2RP1;
    std::vector<int32_t>c2RP2;
    std::array <int32_t, 2>C2RP2 = {{0}};
    std::vector<int64_t>c2LPL;
    std::array <int64_t, 2>C2LPL = {{0}};
    std::vector<int64_t>c2RPL;
    std::array <int64_t, 2>C2RPL = {{0}};
    bool _C2XB = false;
    std::vector<int32_t>c2LB1;
    std::vector<int32_t>c2LB2;
    std::array <int32_t, 2>C2LB2 = {{0}};
    std::vector<int32_t>c2RB1;
    std::vector<int32_t>c2RB2;
    std::array <int32_t, 2>C2RB2 = {{0}};
    std::vector<int64_t>c2LBL;
    std::array <int64_t, 2>C2LBL = {{0}};
    std::vector<int64_t>c2RBL;
    std::array <int64_t, 2>C2RBL = {{0}};
    bool _CDPx = false;
    std::vector<int32_t>cDP3f;
    std::vector<int32_t>cDP3r;
    std::array <int32_t, 2>CDP3b = {{0}};
    std::vector<int32_t>cDP21f;
    std::vector<int32_t>cDP21r;
    std::array <int32_t, 2>CDP21b = {{0}};
    bool _cDPMm = false;
    std::vector<int32_t>cDPMf;
    std::vector<int32_t>cDPMr;
    std::array <int32_t, 2>CDPMb = {{0}};
    std::vector<int32_t>cDPmf;
    std::vector<int32_t>cDPmr;
    std::array <int32_t, 2>CDPmb = {{0}};
    std::array <int32_t, 2>CDPDb = {{0}};
    std::vector<int32_t>cDPDf;
    std::vector<int32_t>cDPDr;
    bool _DDP = false;
    std::array <int32_t, 2>DDP1 = {{0}};
    std::vector<int32_t>dDP1;
    std::array <int32_t, 2>DDP2 = {{0}};
    std::vector<int32_t>dDP2;
    bool _ea = false;
    std::vector<int32_t>aBQ;
    std::vector<int32_t>a2BQf;
    std::vector<int32_t>a2BQr;
    std::vector<int32_t>a2XM2;
    std::vector<int32_t>a2BM2;
    std::vector<int32_t>aBQQ;
    bool _eb = false;
    std::vector<int32_t>bMQ;
    std::vector<int32_t>aAaMQ;
    std::vector<int32_t>bNMQ;
    std::vector<int32_t>bNMa;
    std::vector<int32_t>bNMb;
    std::vector<int32_t>bMQQ;
    bool _eB = false;
    std::vector<int32_t>bIAQb;
    std::vector<int32_t>bIADb;
    std::vector<int32_t>bIDQb;
    bool _eC = false;
    std::vector<int32_t>cIAQf;
    std::vector<int32_t>cIADf;
    std::vector<int32_t>cIDQf;
    std::vector<int32_t>cIAQr;
    std::vector<int32_t>cIADr;
    std::vector<int32_t>cIDQr;
    bool _eE = false;
    std::vector<int32_t>bIAQ;
    std::vector<int32_t>cIAQ;
    std::vector<int32_t>bTINQ;
    std::vector<int32_t>cTINQ;
    bool _eQ1 = false;
    std::vector<int32_t>cPCQ1;
    std::vector<int32_t>cPLQ1;
    std::vector<int32_t>cVQ1;
    std::vector<int32_t>gVQ1;
    bool _eQ2 = false;
    std::vector<int32_t>cPCQ2;
    std::vector<int32_t>cPLQ2;
    std::vector<int32_t>cVQ2;
    std::vector<int32_t>cMmQ;
    std::vector<int32_t>dVQinc;
    bool _CDP1vx = false;
    std::vector<int32_t>cDP1v;
    std::array <int32_t, 2>CDP1v = {{0}};
    std::vector<int32_t>cDP1w;
    std::array <int32_t, 2>CDP1w = {{0}};
    std::vector<int32_t>cDP1x;
    std::array <int32_t, 2>CDP1x = {{0}};
    bool _CDP2vx = false;
    std::vector<int32_t>cDP2v;
    std::array <int32_t, 2>CDP2v = {{0}};
    std::vector<int32_t>cDP2w;
    std::array <int32_t, 2>CDP2w = {{0}};
    std::vector<int32_t>cDP2x;
    std::array <int32_t, 2>CDP2x = {{0}};
    bool _f1 = false;
    std::vector<int32_t>CONTQ;
    std::vector<int32_t>nPF;
    std::vector<int32_t>nNFA;
    std::vector<int32_t>nAFA;
    std::vector<int32_t>nBCFA;
    bool _g1 = false;
    std::vector<int32_t>VTI;
    std::vector<std::string>VTD;
    std::array <int32_t, 2>cVQ1M = {{0}};
    std::array <int32_t, 2>cVQ2M = {{0}};
    std::array <std::string, 2>cVQAM = {{""}};
    std::array <std::string, 2>cVQSM = {{""}};
    bool _g2 = false;
    std::vector<int32_t>gapNf;
    std::vector<int32_t>gapNr;
    std::vector<std::string>gapSeq;
    std::vector<int32_t>gapbAD1;
    std::vector<int32_t>gapcAD1;
    std::vector<int32_t>gc2AD;
    std::vector<int32_t>gc2dAD;
    bool _g3 = false;
    std::vector<int32_t>bDPa;
    std::vector<int32_t>cDP0a;
    std::vector<std::string>gapSa;
    bool _h1 = false;
    std::string bHap = "";
    std::string cHap = "";
    std::string c2Hap = "";
    bool _i1 = false;
    int32_t vHGQ = 0;
    std::array <int32_t, 2>vAC = {{0}};
    std::array <int32_t, 2>vNLODQ = {{0}};
    std::string note = "";
};
static int streamAppendBcfFormat(std::string & outstring, const BcfFormat & fmt) {
if (true) {
    if (fmt.GT.size() == 0) { outstring += "."; }
    outstring += (fmt.GT);

}
if (true) {
    outstring += ":";;
    outstring += std::to_string(fmt.GQ);

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 2; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.HQ[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.FT.size() == 0) { outstring += "."; }
    outstring += (fmt.FT);

}
if (true) {
    outstring += ":";;
    if (fmt.FTS.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.FTS.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += (fmt.FTS[i]);
    };

}
if (true) {
    outstring += ":";;
    outstring += std::string(FORMAT_IDS[5]) + "";

}
if (true) {
    outstring += ":";;
    outstring += std::to_string(fmt.DP);

}
if (true) {
    outstring += ":";;
    if (fmt.AD.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.AD.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.AD[i]);
    };

}
if (true) {
    outstring += ":";;
    outstring += std::to_string(fmt.bDP);

}
if (true) {
    outstring += ":";;
    if (fmt.bAD.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.bAD.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.bAD[i]);
    };

}
if (true) {
    outstring += ":";;
    outstring += std::to_string(fmt.c2DP);

}
if (true) {
    outstring += ":";;
    if (fmt.c2AD.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.c2AD.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.c2AD[i]);
    };

}
if (true) {
    outstring += ":";;
    outstring += std::string(FORMAT_IDS[12]) + "";

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 12; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.APDP[i]);
    };

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 8; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.APXM[i]);
    };

}
if (true) {
    outstring += ":";;
    outstring += std::string(FORMAT_IDS[15]) + "";

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 4; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.APLRID[i]);
    };

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 4; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.APLRI[i]);
    };

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 4; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.APLRP[i]);
    };

}
if (true) {
    outstring += ":";;
    outstring += std::string(FORMAT_IDS[19]) + "";

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 2; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.ALRPxT[i]);
    };

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 4; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.ALRIT[i]);
    };

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 4; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.ALRIt[i]);
    };

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 4; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.ALRPt[i]);
    };

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 4; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.ALRBt[i]);
    };

}
if (true) {
    outstring += ":";;
    outstring += std::string(FORMAT_IDS[25]) + "";

}
if (true) {
    outstring += ":";;
    if (fmt.aMQs.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.aMQs.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.aMQs[i]);
    };

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 1; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.AMQs[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.a1BQf.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.a1BQf.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.a1BQf[i]);
    };

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 1; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.A1BQf[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.a1BQr.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.a1BQr.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.a1BQr[i]);
    };

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 1; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.A1BQr[i]);
    };

}
if (true) {
    outstring += ":";;
    outstring += std::string(FORMAT_IDS[32]) + "";

}
if (true) {
    outstring += ":";;
    if (fmt.aDPff.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.aDPff.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.aDPff[i]);
    };

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 2; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.ADPff[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.aDPfr.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.aDPfr.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.aDPfr[i]);
    };

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 2; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.ADPfr[i]);
    };

}
if (true) {
    outstring += ":";;
    outstring += std::string(FORMAT_IDS[37]) + "";

}
if (true) {
    outstring += ":";;
    if (fmt.aDPrf.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.aDPrf.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.aDPrf[i]);
    };

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 2; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.ADPrf[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.aDPrr.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.aDPrr.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.aDPrr[i]);
    };

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 2; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.ADPrr[i]);
    };

}
if (true) {
    outstring += ":";;
    outstring += std::string(FORMAT_IDS[42]) + "";

}
if (true) {
    outstring += ":";;
    if (fmt.aLP1.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.aLP1.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.aLP1[i]);
    };

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 1; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.ALP1[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.aLP2.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.aLP2.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.aLP2[i]);
    };

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 1; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.ALP2[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.aLPL.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.aLPL.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.aLPL[i]);
    };

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 1; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.ALPL[i]);
    };

}
if (true) {
    outstring += ":";;
    outstring += std::string(FORMAT_IDS[49]) + "";

}
if (true) {
    outstring += ":";;
    if (fmt.aRP1.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.aRP1.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.aRP1[i]);
    };

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 1; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.ARP1[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.aRP2.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.aRP2.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.aRP2[i]);
    };

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 1; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.ARP2[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.aRPL.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.aRPL.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.aRPL[i]);
    };

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 1; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.ARPL[i]);
    };

}
if (true) {
    outstring += ":";;
    outstring += std::string(FORMAT_IDS[56]) + "";

}
if (true) {
    outstring += ":";;
    if (fmt.aLB1.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.aLB1.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.aLB1[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.aLB2.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.aLB2.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.aLB2[i]);
    };

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 1; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.ALB2[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.aLBL.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.aLBL.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.aLBL[i]);
    };

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 1; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.ALBL[i]);
    };

}
if (true) {
    outstring += ":";;
    outstring += std::string(FORMAT_IDS[62]) + "";

}
if (true) {
    outstring += ":";;
    if (fmt.aRB1.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.aRB1.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.aRB1[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.aRB2.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.aRB2.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.aRB2[i]);
    };

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 1; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.ARB2[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.aRBL.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.aRBL.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.aRBL[i]);
    };

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 1; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.ARBL[i]);
    };

}
if (true) {
    outstring += ":";;
    outstring += std::string(FORMAT_IDS[68]) + "";

}
if (true) {
    outstring += ":";;
    if (fmt.aLI1.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.aLI1.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.aLI1[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.aLI2.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.aLI2.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.aLI2[i]);
    };

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 1; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.ALI2[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.aLIr.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.aLIr.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.aLIr[i]);
    };

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 1; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.ALIr[i]);
    };

}
if (true) {
    outstring += ":";;
    outstring += std::string(FORMAT_IDS[74]) + "";

}
if (true) {
    outstring += ":";;
    if (fmt.aRI1.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.aRI1.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.aRI1[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.aRI2.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.aRI2.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.aRI2[i]);
    };

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 1; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.ARI2[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.aRIf.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.aRIf.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.aRIf[i]);
    };

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 1; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.ARIf[i]);
    };

}
if (true) {
    outstring += ":";;
    outstring += std::string(FORMAT_IDS[80]) + "";

}
if (true) {
    outstring += ":";;
    if (fmt.aBQ2.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.aBQ2.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.aBQ2[i]);
    };

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 1; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.ABQ2[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.aPF2.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.aPF2.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.aPF2[i]);
    };

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 1; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.APF2[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.aP1.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.aP1.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.aP1[i]);
    };

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 1; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.AP1[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.aP2.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.aP2.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.aP2[i]);
    };

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 1; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.AP2[i]);
    };

}
if (true) {
    outstring += ":";;
    outstring += std::string(FORMAT_IDS[89]) + "";

}
if (true) {
    outstring += ":";;
    if (fmt.aPF1.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.aPF1.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.aPF1[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.aLIT.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.aLIT.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.aLIT[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.aRIT.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.aRIT.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.aRIT[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.aP3.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.aP3.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.aP3[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.aNC.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.aNC.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.aNC[i]);
    };

}
if (true) {
    outstring += ":";;
    outstring += std::string(FORMAT_IDS[95]) + "";

}
if (true) {
    outstring += ":";;
    if (fmt.bDPf.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.bDPf.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.bDPf[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.bDPr.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.bDPr.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.bDPr[i]);
    };

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 2; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.BDPb[i]);
    };

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 2; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.BDPd[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.bTAf.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.bTAf.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.bTAf[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.bTAr.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.bTAr.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.bTAr[i]);
    };

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 2; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.BTAb[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.bTBf.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.bTBf.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.bTBf[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.bTBr.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.bTBr.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.bTBr[i]);
    };

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 2; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.BTBb[i]);
    };

}
if (true) {
    outstring += ":";;
    outstring += std::string(FORMAT_IDS[106]) + "";

}
if (true) {
    outstring += ":";;
    if (fmt.cDP1f.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.cDP1f.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.cDP1f[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.cDP1r.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.cDP1r.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.cDP1r[i]);
    };

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 2; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.CDP1b[i]);
    };

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 2; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.CDP1d[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.cDP12f.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.cDP12f.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.cDP12f[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.cDP12r.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.cDP12r.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.cDP12r[i]);
    };

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 2; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.CDP12b[i]);
    };

}
if (true) {
    outstring += ":";;
    outstring += std::string(FORMAT_IDS[114]) + "";

}
if (true) {
    outstring += ":";;
    if (fmt.cDP2f.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.cDP2f.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.cDP2f[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.cDP2r.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.cDP2r.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.cDP2r[i]);
    };

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 2; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.CDP2b[i]);
    };

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 2; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.CDP2d[i]);
    };

}
if (fmt.enable_tier2_consensus_format_tags) {
    outstring += ":";;
    if (fmt.c2BQ2.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.c2BQ2.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.c2BQ2[i]);
    };

}
if (fmt.enable_tier2_consensus_format_tags) {
    outstring += ":";;
    for (unsigned int i = 0; i < 1; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.C2BQ2[i]);
    };

}
if (fmt.enable_tier2_consensus_format_tags) {
    outstring += ":";;
    if (fmt.c2LP0.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.c2LP0.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.c2LP0[i]);
    };

}
if (fmt.enable_tier2_consensus_format_tags) {
    outstring += ":";;
    for (unsigned int i = 0; i < 1; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.C2LP0[i]);
    };

}
if (fmt.enable_tier2_consensus_format_tags) {
    outstring += ":";;
    if (fmt.c2RP0.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.c2RP0.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.c2RP0[i]);
    };

}
if (fmt.enable_tier2_consensus_format_tags) {
    outstring += ":";;
    for (unsigned int i = 0; i < 1; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.C2RP0[i]);
    };

}
if (fmt.enable_tier2_consensus_format_tags) {
    outstring += ":";;
    outstring += std::string(FORMAT_IDS[125]) + "";

}
if (fmt.enable_tier2_consensus_format_tags) {
    outstring += ":";;
    if (fmt.c2LP1.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.c2LP1.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.c2LP1[i]);
    };

}
if (fmt.enable_tier2_consensus_format_tags) {
    outstring += ":";;
    if (fmt.c2LP2.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.c2LP2.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.c2LP2[i]);
    };

}
/* The FORMAT/TAG C2LP2 is skipped */
if (fmt.enable_tier2_consensus_format_tags) {
    outstring += ":";;
    if (fmt.c2RP1.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.c2RP1.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.c2RP1[i]);
    };

}
if (fmt.enable_tier2_consensus_format_tags) {
    outstring += ":";;
    if (fmt.c2RP2.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.c2RP2.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.c2RP2[i]);
    };

}
/* The FORMAT/TAG C2RP2 is skipped */
if (fmt.enable_tier2_consensus_format_tags) {
    outstring += ":";;
    if (fmt.c2LPL.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.c2LPL.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.c2LPL[i]);
    };

}
/* The FORMAT/TAG C2LPL is skipped */
if (fmt.enable_tier2_consensus_format_tags) {
    outstring += ":";;
    if (fmt.c2RPL.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.c2RPL.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.c2RPL[i]);
    };

}
/* The FORMAT/TAG C2RPL is skipped */
if (fmt.enable_tier2_consensus_format_tags) {
    outstring += ":";;
    outstring += std::string(FORMAT_IDS[136]) + "";

}
if (fmt.enable_tier2_consensus_format_tags) {
    outstring += ":";;
    if (fmt.c2LB1.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.c2LB1.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.c2LB1[i]);
    };

}
if (fmt.enable_tier2_consensus_format_tags) {
    outstring += ":";;
    if (fmt.c2LB2.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.c2LB2.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.c2LB2[i]);
    };

}
/* The FORMAT/TAG C2LB2 is skipped */
if (fmt.enable_tier2_consensus_format_tags) {
    outstring += ":";;
    if (fmt.c2RB1.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.c2RB1.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.c2RB1[i]);
    };

}
if (fmt.enable_tier2_consensus_format_tags) {
    outstring += ":";;
    if (fmt.c2RB2.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.c2RB2.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.c2RB2[i]);
    };

}
/* The FORMAT/TAG C2RB2 is skipped */
if (fmt.enable_tier2_consensus_format_tags) {
    outstring += ":";;
    if (fmt.c2LBL.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.c2LBL.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.c2LBL[i]);
    };

}
/* The FORMAT/TAG C2LBL is skipped */
if (fmt.enable_tier2_consensus_format_tags) {
    outstring += ":";;
    if (fmt.c2RBL.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.c2RBL.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.c2RBL[i]);
    };

}
/* The FORMAT/TAG C2RBL is skipped */
if (fmt.enable_tier2_consensus_format_tags) {
    outstring += ":";;
    outstring += std::string(FORMAT_IDS[147]) + "";

}
if (fmt.enable_tier2_consensus_format_tags) {
    outstring += ":";;
    if (fmt.cDP3f.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.cDP3f.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.cDP3f[i]);
    };

}
if (fmt.enable_tier2_consensus_format_tags) {
    outstring += ":";;
    if (fmt.cDP3r.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.cDP3r.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.cDP3r[i]);
    };

}
if (fmt.enable_tier2_consensus_format_tags) {
    outstring += ":";;
    for (unsigned int i = 0; i < 2; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.CDP3b[i]);
    };

}
if (fmt.enable_tier2_consensus_format_tags) {
    outstring += ":";;
    if (fmt.cDP21f.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.cDP21f.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.cDP21f[i]);
    };

}
if (fmt.enable_tier2_consensus_format_tags) {
    outstring += ":";;
    if (fmt.cDP21r.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.cDP21r.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.cDP21r[i]);
    };

}
if (fmt.enable_tier2_consensus_format_tags) {
    outstring += ":";;
    for (unsigned int i = 0; i < 2; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.CDP21b[i]);
    };

}
if (fmt.enable_tier2_consensus_format_tags) {
    outstring += ":";;
    outstring += std::string(FORMAT_IDS[154]) + "";

}
if (fmt.enable_tier2_consensus_format_tags) {
    outstring += ":";;
    if (fmt.cDPMf.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.cDPMf.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.cDPMf[i]);
    };

}
if (fmt.enable_tier2_consensus_format_tags) {
    outstring += ":";;
    if (fmt.cDPMr.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.cDPMr.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.cDPMr[i]);
    };

}
if (fmt.enable_tier2_consensus_format_tags) {
    outstring += ":";;
    for (unsigned int i = 0; i < 2; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.CDPMb[i]);
    };

}
if (fmt.enable_tier2_consensus_format_tags) {
    outstring += ":";;
    if (fmt.cDPmf.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.cDPmf.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.cDPmf[i]);
    };

}
if (fmt.enable_tier2_consensus_format_tags) {
    outstring += ":";;
    if (fmt.cDPmr.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.cDPmr.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.cDPmr[i]);
    };

}
if (fmt.enable_tier2_consensus_format_tags) {
    outstring += ":";;
    for (unsigned int i = 0; i < 2; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.CDPmb[i]);
    };

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 2; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.CDPDb[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.cDPDf.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.cDPDf.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.cDPDf[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.cDPDr.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.cDPDr.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.cDPDr[i]);
    };

}
if (true) {
    outstring += ":";;
    outstring += std::string(FORMAT_IDS[164]) + "";

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 2; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.DDP1[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.dDP1.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.dDP1.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.dDP1[i]);
    };

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 2; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.DDP2[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.dDP2.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.dDP2.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.dDP2[i]);
    };

}
if (true) {
    outstring += ":";;
    outstring += std::string(FORMAT_IDS[169]) + "";

}
if (true) {
    outstring += ":";;
    if (fmt.aBQ.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.aBQ.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.aBQ[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.a2BQf.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.a2BQf.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.a2BQf[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.a2BQr.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.a2BQr.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.a2BQr[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.a2XM2.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.a2XM2.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.a2XM2[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.a2BM2.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.a2BM2.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.a2BM2[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.aBQQ.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.aBQQ.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.aBQQ[i]);
    };

}
if (true) {
    outstring += ":";;
    outstring += std::string(FORMAT_IDS[176]) + "";

}
if (true) {
    outstring += ":";;
    if (fmt.bMQ.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.bMQ.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.bMQ[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.aAaMQ.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.aAaMQ.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.aAaMQ[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.bNMQ.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.bNMQ.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.bNMQ[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.bNMa.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.bNMa.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.bNMa[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.bNMb.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.bNMb.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.bNMb[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.bMQQ.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.bMQQ.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.bMQQ[i]);
    };

}
if (true) {
    outstring += ":";;
    outstring += std::string(FORMAT_IDS[183]) + "";

}
if (true) {
    outstring += ":";;
    if (fmt.bIAQb.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.bIAQb.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.bIAQb[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.bIADb.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.bIADb.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.bIADb[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.bIDQb.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.bIDQb.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.bIDQb[i]);
    };

}
if (true) {
    outstring += ":";;
    outstring += std::string(FORMAT_IDS[187]) + "";

}
if (true) {
    outstring += ":";;
    if (fmt.cIAQf.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.cIAQf.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.cIAQf[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.cIADf.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.cIADf.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.cIADf[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.cIDQf.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.cIDQf.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.cIDQf[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.cIAQr.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.cIAQr.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.cIAQr[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.cIADr.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.cIADr.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.cIADr[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.cIDQr.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.cIDQr.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.cIDQr[i]);
    };

}
if (true) {
    outstring += ":";;
    outstring += std::string(FORMAT_IDS[194]) + "";

}
if (true) {
    outstring += ":";;
    if (fmt.bIAQ.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.bIAQ.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.bIAQ[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.cIAQ.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.cIAQ.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.cIAQ[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.bTINQ.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.bTINQ.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.bTINQ[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.cTINQ.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.cTINQ.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.cTINQ[i]);
    };

}
if (true) {
    outstring += ":";;
    outstring += std::string(FORMAT_IDS[199]) + "";

}
if (true) {
    outstring += ":";;
    if (fmt.cPCQ1.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.cPCQ1.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.cPCQ1[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.cPLQ1.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.cPLQ1.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.cPLQ1[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.cVQ1.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.cVQ1.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.cVQ1[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.gVQ1.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.gVQ1.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.gVQ1[i]);
    };

}
if (true) {
    outstring += ":";;
    outstring += std::string(FORMAT_IDS[204]) + "";

}
if (true) {
    outstring += ":";;
    if (fmt.cPCQ2.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.cPCQ2.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.cPCQ2[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.cPLQ2.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.cPLQ2.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.cPLQ2[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.cVQ2.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.cVQ2.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.cVQ2[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.cMmQ.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.cMmQ.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.cMmQ[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.dVQinc.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.dVQinc.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.dVQinc[i]);
    };

}
if (true) {
    outstring += ":";;
    outstring += std::string(FORMAT_IDS[210]) + "";

}
if (true) {
    outstring += ":";;
    if (fmt.cDP1v.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.cDP1v.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.cDP1v[i]);
    };

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 2; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.CDP1v[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.cDP1w.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.cDP1w.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.cDP1w[i]);
    };

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 1; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.CDP1w[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.cDP1x.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.cDP1x.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.cDP1x[i]);
    };

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 1; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.CDP1x[i]);
    };

}
if (true) {
    outstring += ":";;
    outstring += std::string(FORMAT_IDS[217]) + "";

}
if (true) {
    outstring += ":";;
    if (fmt.cDP2v.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.cDP2v.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.cDP2v[i]);
    };

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 2; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.CDP2v[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.cDP2w.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.cDP2w.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.cDP2w[i]);
    };

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 1; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.CDP2w[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.cDP2x.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.cDP2x.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.cDP2x[i]);
    };

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 1; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.CDP2x[i]);
    };

}
if (true) {
    outstring += ":";;
    outstring += std::string(FORMAT_IDS[224]) + "";

}
if (true) {
    outstring += ":";;
    if (fmt.CONTQ.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.CONTQ.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.CONTQ[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.nPF.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.nPF.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.nPF[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.nNFA.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.nNFA.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.nNFA[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.nAFA.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.nAFA.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.nAFA[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.nBCFA.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.nBCFA.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.nBCFA[i]);
    };

}
if (true) {
    outstring += ":";;
    outstring += std::string(FORMAT_IDS[230]) + "";

}
if (true) {
    outstring += ":";;
    if (fmt.VTI.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.VTI.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.VTI[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.VTD.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.VTD.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += (fmt.VTD[i]);
    };

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 2; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.cVQ1M[i]);
    };

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 2; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.cVQ2M[i]);
    };

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 2; i++) {
        if (0 != i) { outstring += ","; }; outstring += (fmt.cVQAM[i]);
    };

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 2; i++) {
        if (0 != i) { outstring += ","; }; outstring += (fmt.cVQSM[i]);
    };

}
if (true) {
    outstring += ":";;
    outstring += std::string(FORMAT_IDS[237]) + "";

}
if (true) {
    outstring += ":";;
    if (fmt.gapNf.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.gapNf.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.gapNf[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.gapNr.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.gapNr.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.gapNr[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.gapSeq.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.gapSeq.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += (fmt.gapSeq[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.gapbAD1.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.gapbAD1.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.gapbAD1[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.gapcAD1.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.gapcAD1.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.gapcAD1[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.gc2AD.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.gc2AD.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.gc2AD[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.gc2dAD.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.gc2dAD.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.gc2dAD[i]);
    };

}
if (true) {
    outstring += ":";;
    outstring += std::string(FORMAT_IDS[245]) + "";

}
if (true) {
    outstring += ":";;
    if (fmt.bDPa.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.bDPa.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.bDPa[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.cDP0a.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.cDP0a.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.cDP0a[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.gapSa.size() == 0) { outstring += "."; }
    for (unsigned int i = 0; i <  fmt.gapSa.size(); i++) {
        if (0 != i) { outstring += ","; }; outstring += (fmt.gapSa[i]);
    };

}
if (true) {
    outstring += ":";;
    outstring += std::string(FORMAT_IDS[249]) + "";

}
if (true) {
    outstring += ":";;
    if (fmt.bHap.size() == 0) { outstring += "."; }
    outstring += (fmt.bHap);

}
if (true) {
    outstring += ":";;
    if (fmt.cHap.size() == 0) { outstring += "."; }
    outstring += (fmt.cHap);

}
if (true) {
    outstring += ":";;
    if (fmt.c2Hap.size() == 0) { outstring += "."; }
    outstring += (fmt.c2Hap);

}
if (true) {
    outstring += ":";;
    outstring += std::string(FORMAT_IDS[253]) + "";

}
if (true) {
    outstring += ":";;
    outstring += std::to_string(fmt.vHGQ);

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 2; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.vAC[i]);
    };

}
if (true) {
    outstring += ":";;
    for (unsigned int i = 0; i < 2; i++) {
        if (0 != i) { outstring += ","; }; outstring += std::to_string(fmt.vNLODQ[i]);
    };

}
if (true) {
    outstring += ":";;
    if (fmt.note.size() == 0) { outstring += "."; }
    outstring += (fmt.note);

}

    return 0;};
static int resetBcfFormatD(BcfFormat & fmt) {
    fmt.nPF.clear();
    fmt.nNFA.clear();
    fmt.nAFA.clear();
    fmt.nBCFA.clear();
    fmt.gapNf.clear();
    fmt.gapNr.clear();
    fmt.gapSeq.clear();
    fmt.gapbAD1.clear();
    fmt.gapcAD1.clear();
    fmt.gc2AD.clear();
    fmt.gc2dAD.clear();

    return 0;};
static int streamFrontPushBcfFormatR(BcfFormat & dst, const BcfFormat & src) {
    assert(dst.AD.size() == 1 || !fprintf(stderr, "%lu == 1 failed for AD", dst.AD.size() ) );
    assert(src.AD.size() == 1 || !fprintf(stderr, "%lu == 1 failed for AD", src.AD.size() ) );
    auto AD_tmp = dst.AD[0];
    dst.AD[0] = src.AD[0];
    dst.AD.push_back(AD_tmp);
    assert(dst.bAD.size() == 1 || !fprintf(stderr, "%lu == 1 failed for bAD", dst.bAD.size() ) );
    assert(src.bAD.size() == 1 || !fprintf(stderr, "%lu == 1 failed for bAD", src.bAD.size() ) );
    auto bAD_tmp = dst.bAD[0];
    dst.bAD[0] = src.bAD[0];
    dst.bAD.push_back(bAD_tmp);
    assert(dst.c2AD.size() == 1 || !fprintf(stderr, "%lu == 1 failed for c2AD", dst.c2AD.size() ) );
    assert(src.c2AD.size() == 1 || !fprintf(stderr, "%lu == 1 failed for c2AD", src.c2AD.size() ) );
    auto c2AD_tmp = dst.c2AD[0];
    dst.c2AD[0] = src.c2AD[0];
    dst.c2AD.push_back(c2AD_tmp);
    assert(dst.aMQs.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aMQs", dst.aMQs.size() ) );
    assert(src.aMQs.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aMQs", src.aMQs.size() ) );
    auto aMQs_tmp = dst.aMQs[0];
    dst.aMQs[0] = src.aMQs[0];
    dst.aMQs.push_back(aMQs_tmp);
    assert(dst.a1BQf.size() == 1 || !fprintf(stderr, "%lu == 1 failed for a1BQf", dst.a1BQf.size() ) );
    assert(src.a1BQf.size() == 1 || !fprintf(stderr, "%lu == 1 failed for a1BQf", src.a1BQf.size() ) );
    auto a1BQf_tmp = dst.a1BQf[0];
    dst.a1BQf[0] = src.a1BQf[0];
    dst.a1BQf.push_back(a1BQf_tmp);
    assert(dst.a1BQr.size() == 1 || !fprintf(stderr, "%lu == 1 failed for a1BQr", dst.a1BQr.size() ) );
    assert(src.a1BQr.size() == 1 || !fprintf(stderr, "%lu == 1 failed for a1BQr", src.a1BQr.size() ) );
    auto a1BQr_tmp = dst.a1BQr[0];
    dst.a1BQr[0] = src.a1BQr[0];
    dst.a1BQr.push_back(a1BQr_tmp);
    assert(dst.aDPff.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aDPff", dst.aDPff.size() ) );
    assert(src.aDPff.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aDPff", src.aDPff.size() ) );
    auto aDPff_tmp = dst.aDPff[0];
    dst.aDPff[0] = src.aDPff[0];
    dst.aDPff.push_back(aDPff_tmp);
    assert(dst.aDPfr.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aDPfr", dst.aDPfr.size() ) );
    assert(src.aDPfr.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aDPfr", src.aDPfr.size() ) );
    auto aDPfr_tmp = dst.aDPfr[0];
    dst.aDPfr[0] = src.aDPfr[0];
    dst.aDPfr.push_back(aDPfr_tmp);
    assert(dst.aDPrf.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aDPrf", dst.aDPrf.size() ) );
    assert(src.aDPrf.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aDPrf", src.aDPrf.size() ) );
    auto aDPrf_tmp = dst.aDPrf[0];
    dst.aDPrf[0] = src.aDPrf[0];
    dst.aDPrf.push_back(aDPrf_tmp);
    assert(dst.aDPrr.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aDPrr", dst.aDPrr.size() ) );
    assert(src.aDPrr.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aDPrr", src.aDPrr.size() ) );
    auto aDPrr_tmp = dst.aDPrr[0];
    dst.aDPrr[0] = src.aDPrr[0];
    dst.aDPrr.push_back(aDPrr_tmp);
    assert(dst.aLP1.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aLP1", dst.aLP1.size() ) );
    assert(src.aLP1.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aLP1", src.aLP1.size() ) );
    auto aLP1_tmp = dst.aLP1[0];
    dst.aLP1[0] = src.aLP1[0];
    dst.aLP1.push_back(aLP1_tmp);
    assert(dst.aLP2.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aLP2", dst.aLP2.size() ) );
    assert(src.aLP2.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aLP2", src.aLP2.size() ) );
    auto aLP2_tmp = dst.aLP2[0];
    dst.aLP2[0] = src.aLP2[0];
    dst.aLP2.push_back(aLP2_tmp);
    assert(dst.aLPL.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aLPL", dst.aLPL.size() ) );
    assert(src.aLPL.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aLPL", src.aLPL.size() ) );
    auto aLPL_tmp = dst.aLPL[0];
    dst.aLPL[0] = src.aLPL[0];
    dst.aLPL.push_back(aLPL_tmp);
    assert(dst.aRP1.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aRP1", dst.aRP1.size() ) );
    assert(src.aRP1.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aRP1", src.aRP1.size() ) );
    auto aRP1_tmp = dst.aRP1[0];
    dst.aRP1[0] = src.aRP1[0];
    dst.aRP1.push_back(aRP1_tmp);
    assert(dst.aRP2.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aRP2", dst.aRP2.size() ) );
    assert(src.aRP2.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aRP2", src.aRP2.size() ) );
    auto aRP2_tmp = dst.aRP2[0];
    dst.aRP2[0] = src.aRP2[0];
    dst.aRP2.push_back(aRP2_tmp);
    assert(dst.aRPL.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aRPL", dst.aRPL.size() ) );
    assert(src.aRPL.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aRPL", src.aRPL.size() ) );
    auto aRPL_tmp = dst.aRPL[0];
    dst.aRPL[0] = src.aRPL[0];
    dst.aRPL.push_back(aRPL_tmp);
    assert(dst.aLB1.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aLB1", dst.aLB1.size() ) );
    assert(src.aLB1.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aLB1", src.aLB1.size() ) );
    auto aLB1_tmp = dst.aLB1[0];
    dst.aLB1[0] = src.aLB1[0];
    dst.aLB1.push_back(aLB1_tmp);
    assert(dst.aLB2.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aLB2", dst.aLB2.size() ) );
    assert(src.aLB2.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aLB2", src.aLB2.size() ) );
    auto aLB2_tmp = dst.aLB2[0];
    dst.aLB2[0] = src.aLB2[0];
    dst.aLB2.push_back(aLB2_tmp);
    assert(dst.aLBL.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aLBL", dst.aLBL.size() ) );
    assert(src.aLBL.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aLBL", src.aLBL.size() ) );
    auto aLBL_tmp = dst.aLBL[0];
    dst.aLBL[0] = src.aLBL[0];
    dst.aLBL.push_back(aLBL_tmp);
    assert(dst.aRB1.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aRB1", dst.aRB1.size() ) );
    assert(src.aRB1.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aRB1", src.aRB1.size() ) );
    auto aRB1_tmp = dst.aRB1[0];
    dst.aRB1[0] = src.aRB1[0];
    dst.aRB1.push_back(aRB1_tmp);
    assert(dst.aRB2.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aRB2", dst.aRB2.size() ) );
    assert(src.aRB2.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aRB2", src.aRB2.size() ) );
    auto aRB2_tmp = dst.aRB2[0];
    dst.aRB2[0] = src.aRB2[0];
    dst.aRB2.push_back(aRB2_tmp);
    assert(dst.aRBL.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aRBL", dst.aRBL.size() ) );
    assert(src.aRBL.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aRBL", src.aRBL.size() ) );
    auto aRBL_tmp = dst.aRBL[0];
    dst.aRBL[0] = src.aRBL[0];
    dst.aRBL.push_back(aRBL_tmp);
    assert(dst.aLI1.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aLI1", dst.aLI1.size() ) );
    assert(src.aLI1.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aLI1", src.aLI1.size() ) );
    auto aLI1_tmp = dst.aLI1[0];
    dst.aLI1[0] = src.aLI1[0];
    dst.aLI1.push_back(aLI1_tmp);
    assert(dst.aLI2.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aLI2", dst.aLI2.size() ) );
    assert(src.aLI2.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aLI2", src.aLI2.size() ) );
    auto aLI2_tmp = dst.aLI2[0];
    dst.aLI2[0] = src.aLI2[0];
    dst.aLI2.push_back(aLI2_tmp);
    assert(dst.aLIr.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aLIr", dst.aLIr.size() ) );
    assert(src.aLIr.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aLIr", src.aLIr.size() ) );
    auto aLIr_tmp = dst.aLIr[0];
    dst.aLIr[0] = src.aLIr[0];
    dst.aLIr.push_back(aLIr_tmp);
    assert(dst.aRI1.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aRI1", dst.aRI1.size() ) );
    assert(src.aRI1.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aRI1", src.aRI1.size() ) );
    auto aRI1_tmp = dst.aRI1[0];
    dst.aRI1[0] = src.aRI1[0];
    dst.aRI1.push_back(aRI1_tmp);
    assert(dst.aRI2.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aRI2", dst.aRI2.size() ) );
    assert(src.aRI2.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aRI2", src.aRI2.size() ) );
    auto aRI2_tmp = dst.aRI2[0];
    dst.aRI2[0] = src.aRI2[0];
    dst.aRI2.push_back(aRI2_tmp);
    assert(dst.aRIf.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aRIf", dst.aRIf.size() ) );
    assert(src.aRIf.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aRIf", src.aRIf.size() ) );
    auto aRIf_tmp = dst.aRIf[0];
    dst.aRIf[0] = src.aRIf[0];
    dst.aRIf.push_back(aRIf_tmp);
    assert(dst.aBQ2.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aBQ2", dst.aBQ2.size() ) );
    assert(src.aBQ2.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aBQ2", src.aBQ2.size() ) );
    auto aBQ2_tmp = dst.aBQ2[0];
    dst.aBQ2[0] = src.aBQ2[0];
    dst.aBQ2.push_back(aBQ2_tmp);
    assert(dst.aPF2.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aPF2", dst.aPF2.size() ) );
    assert(src.aPF2.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aPF2", src.aPF2.size() ) );
    auto aPF2_tmp = dst.aPF2[0];
    dst.aPF2[0] = src.aPF2[0];
    dst.aPF2.push_back(aPF2_tmp);
    assert(dst.aP1.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aP1", dst.aP1.size() ) );
    assert(src.aP1.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aP1", src.aP1.size() ) );
    auto aP1_tmp = dst.aP1[0];
    dst.aP1[0] = src.aP1[0];
    dst.aP1.push_back(aP1_tmp);
    assert(dst.aP2.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aP2", dst.aP2.size() ) );
    assert(src.aP2.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aP2", src.aP2.size() ) );
    auto aP2_tmp = dst.aP2[0];
    dst.aP2[0] = src.aP2[0];
    dst.aP2.push_back(aP2_tmp);
    assert(dst.aPF1.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aPF1", dst.aPF1.size() ) );
    assert(src.aPF1.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aPF1", src.aPF1.size() ) );
    auto aPF1_tmp = dst.aPF1[0];
    dst.aPF1[0] = src.aPF1[0];
    dst.aPF1.push_back(aPF1_tmp);
    assert(dst.aLIT.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aLIT", dst.aLIT.size() ) );
    assert(src.aLIT.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aLIT", src.aLIT.size() ) );
    auto aLIT_tmp = dst.aLIT[0];
    dst.aLIT[0] = src.aLIT[0];
    dst.aLIT.push_back(aLIT_tmp);
    assert(dst.aRIT.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aRIT", dst.aRIT.size() ) );
    assert(src.aRIT.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aRIT", src.aRIT.size() ) );
    auto aRIT_tmp = dst.aRIT[0];
    dst.aRIT[0] = src.aRIT[0];
    dst.aRIT.push_back(aRIT_tmp);
    assert(dst.aP3.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aP3", dst.aP3.size() ) );
    assert(src.aP3.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aP3", src.aP3.size() ) );
    auto aP3_tmp = dst.aP3[0];
    dst.aP3[0] = src.aP3[0];
    dst.aP3.push_back(aP3_tmp);
    assert(dst.aNC.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aNC", dst.aNC.size() ) );
    assert(src.aNC.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aNC", src.aNC.size() ) );
    auto aNC_tmp = dst.aNC[0];
    dst.aNC[0] = src.aNC[0];
    dst.aNC.push_back(aNC_tmp);
    assert(dst.bDPf.size() == 1 || !fprintf(stderr, "%lu == 1 failed for bDPf", dst.bDPf.size() ) );
    assert(src.bDPf.size() == 1 || !fprintf(stderr, "%lu == 1 failed for bDPf", src.bDPf.size() ) );
    auto bDPf_tmp = dst.bDPf[0];
    dst.bDPf[0] = src.bDPf[0];
    dst.bDPf.push_back(bDPf_tmp);
    assert(dst.bDPr.size() == 1 || !fprintf(stderr, "%lu == 1 failed for bDPr", dst.bDPr.size() ) );
    assert(src.bDPr.size() == 1 || !fprintf(stderr, "%lu == 1 failed for bDPr", src.bDPr.size() ) );
    auto bDPr_tmp = dst.bDPr[0];
    dst.bDPr[0] = src.bDPr[0];
    dst.bDPr.push_back(bDPr_tmp);
    assert(dst.bTAf.size() == 1 || !fprintf(stderr, "%lu == 1 failed for bTAf", dst.bTAf.size() ) );
    assert(src.bTAf.size() == 1 || !fprintf(stderr, "%lu == 1 failed for bTAf", src.bTAf.size() ) );
    auto bTAf_tmp = dst.bTAf[0];
    dst.bTAf[0] = src.bTAf[0];
    dst.bTAf.push_back(bTAf_tmp);
    assert(dst.bTAr.size() == 1 || !fprintf(stderr, "%lu == 1 failed for bTAr", dst.bTAr.size() ) );
    assert(src.bTAr.size() == 1 || !fprintf(stderr, "%lu == 1 failed for bTAr", src.bTAr.size() ) );
    auto bTAr_tmp = dst.bTAr[0];
    dst.bTAr[0] = src.bTAr[0];
    dst.bTAr.push_back(bTAr_tmp);
    assert(dst.bTBf.size() == 1 || !fprintf(stderr, "%lu == 1 failed for bTBf", dst.bTBf.size() ) );
    assert(src.bTBf.size() == 1 || !fprintf(stderr, "%lu == 1 failed for bTBf", src.bTBf.size() ) );
    auto bTBf_tmp = dst.bTBf[0];
    dst.bTBf[0] = src.bTBf[0];
    dst.bTBf.push_back(bTBf_tmp);
    assert(dst.bTBr.size() == 1 || !fprintf(stderr, "%lu == 1 failed for bTBr", dst.bTBr.size() ) );
    assert(src.bTBr.size() == 1 || !fprintf(stderr, "%lu == 1 failed for bTBr", src.bTBr.size() ) );
    auto bTBr_tmp = dst.bTBr[0];
    dst.bTBr[0] = src.bTBr[0];
    dst.bTBr.push_back(bTBr_tmp);
    assert(dst.cDP1f.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cDP1f", dst.cDP1f.size() ) );
    assert(src.cDP1f.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cDP1f", src.cDP1f.size() ) );
    auto cDP1f_tmp = dst.cDP1f[0];
    dst.cDP1f[0] = src.cDP1f[0];
    dst.cDP1f.push_back(cDP1f_tmp);
    assert(dst.cDP1r.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cDP1r", dst.cDP1r.size() ) );
    assert(src.cDP1r.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cDP1r", src.cDP1r.size() ) );
    auto cDP1r_tmp = dst.cDP1r[0];
    dst.cDP1r[0] = src.cDP1r[0];
    dst.cDP1r.push_back(cDP1r_tmp);
    assert(dst.cDP12f.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cDP12f", dst.cDP12f.size() ) );
    assert(src.cDP12f.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cDP12f", src.cDP12f.size() ) );
    auto cDP12f_tmp = dst.cDP12f[0];
    dst.cDP12f[0] = src.cDP12f[0];
    dst.cDP12f.push_back(cDP12f_tmp);
    assert(dst.cDP12r.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cDP12r", dst.cDP12r.size() ) );
    assert(src.cDP12r.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cDP12r", src.cDP12r.size() ) );
    auto cDP12r_tmp = dst.cDP12r[0];
    dst.cDP12r[0] = src.cDP12r[0];
    dst.cDP12r.push_back(cDP12r_tmp);
    assert(dst.cDP2f.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cDP2f", dst.cDP2f.size() ) );
    assert(src.cDP2f.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cDP2f", src.cDP2f.size() ) );
    auto cDP2f_tmp = dst.cDP2f[0];
    dst.cDP2f[0] = src.cDP2f[0];
    dst.cDP2f.push_back(cDP2f_tmp);
    assert(dst.cDP2r.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cDP2r", dst.cDP2r.size() ) );
    assert(src.cDP2r.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cDP2r", src.cDP2r.size() ) );
    auto cDP2r_tmp = dst.cDP2r[0];
    dst.cDP2r[0] = src.cDP2r[0];
    dst.cDP2r.push_back(cDP2r_tmp);
    assert(dst.c2BQ2.size() == 1 || !fprintf(stderr, "%lu == 1 failed for c2BQ2", dst.c2BQ2.size() ) );
    assert(src.c2BQ2.size() == 1 || !fprintf(stderr, "%lu == 1 failed for c2BQ2", src.c2BQ2.size() ) );
    auto c2BQ2_tmp = dst.c2BQ2[0];
    dst.c2BQ2[0] = src.c2BQ2[0];
    dst.c2BQ2.push_back(c2BQ2_tmp);
    assert(dst.c2LP0.size() == 1 || !fprintf(stderr, "%lu == 1 failed for c2LP0", dst.c2LP0.size() ) );
    assert(src.c2LP0.size() == 1 || !fprintf(stderr, "%lu == 1 failed for c2LP0", src.c2LP0.size() ) );
    auto c2LP0_tmp = dst.c2LP0[0];
    dst.c2LP0[0] = src.c2LP0[0];
    dst.c2LP0.push_back(c2LP0_tmp);
    assert(dst.c2RP0.size() == 1 || !fprintf(stderr, "%lu == 1 failed for c2RP0", dst.c2RP0.size() ) );
    assert(src.c2RP0.size() == 1 || !fprintf(stderr, "%lu == 1 failed for c2RP0", src.c2RP0.size() ) );
    auto c2RP0_tmp = dst.c2RP0[0];
    dst.c2RP0[0] = src.c2RP0[0];
    dst.c2RP0.push_back(c2RP0_tmp);
    assert(dst.c2LP1.size() == 1 || !fprintf(stderr, "%lu == 1 failed for c2LP1", dst.c2LP1.size() ) );
    assert(src.c2LP1.size() == 1 || !fprintf(stderr, "%lu == 1 failed for c2LP1", src.c2LP1.size() ) );
    auto c2LP1_tmp = dst.c2LP1[0];
    dst.c2LP1[0] = src.c2LP1[0];
    dst.c2LP1.push_back(c2LP1_tmp);
    assert(dst.c2LP2.size() == 1 || !fprintf(stderr, "%lu == 1 failed for c2LP2", dst.c2LP2.size() ) );
    assert(src.c2LP2.size() == 1 || !fprintf(stderr, "%lu == 1 failed for c2LP2", src.c2LP2.size() ) );
    auto c2LP2_tmp = dst.c2LP2[0];
    dst.c2LP2[0] = src.c2LP2[0];
    dst.c2LP2.push_back(c2LP2_tmp);
    assert(dst.c2RP1.size() == 1 || !fprintf(stderr, "%lu == 1 failed for c2RP1", dst.c2RP1.size() ) );
    assert(src.c2RP1.size() == 1 || !fprintf(stderr, "%lu == 1 failed for c2RP1", src.c2RP1.size() ) );
    auto c2RP1_tmp = dst.c2RP1[0];
    dst.c2RP1[0] = src.c2RP1[0];
    dst.c2RP1.push_back(c2RP1_tmp);
    assert(dst.c2RP2.size() == 1 || !fprintf(stderr, "%lu == 1 failed for c2RP2", dst.c2RP2.size() ) );
    assert(src.c2RP2.size() == 1 || !fprintf(stderr, "%lu == 1 failed for c2RP2", src.c2RP2.size() ) );
    auto c2RP2_tmp = dst.c2RP2[0];
    dst.c2RP2[0] = src.c2RP2[0];
    dst.c2RP2.push_back(c2RP2_tmp);
    assert(dst.c2LPL.size() == 1 || !fprintf(stderr, "%lu == 1 failed for c2LPL", dst.c2LPL.size() ) );
    assert(src.c2LPL.size() == 1 || !fprintf(stderr, "%lu == 1 failed for c2LPL", src.c2LPL.size() ) );
    auto c2LPL_tmp = dst.c2LPL[0];
    dst.c2LPL[0] = src.c2LPL[0];
    dst.c2LPL.push_back(c2LPL_tmp);
    assert(dst.c2RPL.size() == 1 || !fprintf(stderr, "%lu == 1 failed for c2RPL", dst.c2RPL.size() ) );
    assert(src.c2RPL.size() == 1 || !fprintf(stderr, "%lu == 1 failed for c2RPL", src.c2RPL.size() ) );
    auto c2RPL_tmp = dst.c2RPL[0];
    dst.c2RPL[0] = src.c2RPL[0];
    dst.c2RPL.push_back(c2RPL_tmp);
    assert(dst.c2LB1.size() == 1 || !fprintf(stderr, "%lu == 1 failed for c2LB1", dst.c2LB1.size() ) );
    assert(src.c2LB1.size() == 1 || !fprintf(stderr, "%lu == 1 failed for c2LB1", src.c2LB1.size() ) );
    auto c2LB1_tmp = dst.c2LB1[0];
    dst.c2LB1[0] = src.c2LB1[0];
    dst.c2LB1.push_back(c2LB1_tmp);
    assert(dst.c2LB2.size() == 1 || !fprintf(stderr, "%lu == 1 failed for c2LB2", dst.c2LB2.size() ) );
    assert(src.c2LB2.size() == 1 || !fprintf(stderr, "%lu == 1 failed for c2LB2", src.c2LB2.size() ) );
    auto c2LB2_tmp = dst.c2LB2[0];
    dst.c2LB2[0] = src.c2LB2[0];
    dst.c2LB2.push_back(c2LB2_tmp);
    assert(dst.c2RB1.size() == 1 || !fprintf(stderr, "%lu == 1 failed for c2RB1", dst.c2RB1.size() ) );
    assert(src.c2RB1.size() == 1 || !fprintf(stderr, "%lu == 1 failed for c2RB1", src.c2RB1.size() ) );
    auto c2RB1_tmp = dst.c2RB1[0];
    dst.c2RB1[0] = src.c2RB1[0];
    dst.c2RB1.push_back(c2RB1_tmp);
    assert(dst.c2RB2.size() == 1 || !fprintf(stderr, "%lu == 1 failed for c2RB2", dst.c2RB2.size() ) );
    assert(src.c2RB2.size() == 1 || !fprintf(stderr, "%lu == 1 failed for c2RB2", src.c2RB2.size() ) );
    auto c2RB2_tmp = dst.c2RB2[0];
    dst.c2RB2[0] = src.c2RB2[0];
    dst.c2RB2.push_back(c2RB2_tmp);
    assert(dst.c2LBL.size() == 1 || !fprintf(stderr, "%lu == 1 failed for c2LBL", dst.c2LBL.size() ) );
    assert(src.c2LBL.size() == 1 || !fprintf(stderr, "%lu == 1 failed for c2LBL", src.c2LBL.size() ) );
    auto c2LBL_tmp = dst.c2LBL[0];
    dst.c2LBL[0] = src.c2LBL[0];
    dst.c2LBL.push_back(c2LBL_tmp);
    assert(dst.c2RBL.size() == 1 || !fprintf(stderr, "%lu == 1 failed for c2RBL", dst.c2RBL.size() ) );
    assert(src.c2RBL.size() == 1 || !fprintf(stderr, "%lu == 1 failed for c2RBL", src.c2RBL.size() ) );
    auto c2RBL_tmp = dst.c2RBL[0];
    dst.c2RBL[0] = src.c2RBL[0];
    dst.c2RBL.push_back(c2RBL_tmp);
    assert(dst.cDP3f.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cDP3f", dst.cDP3f.size() ) );
    assert(src.cDP3f.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cDP3f", src.cDP3f.size() ) );
    auto cDP3f_tmp = dst.cDP3f[0];
    dst.cDP3f[0] = src.cDP3f[0];
    dst.cDP3f.push_back(cDP3f_tmp);
    assert(dst.cDP3r.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cDP3r", dst.cDP3r.size() ) );
    assert(src.cDP3r.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cDP3r", src.cDP3r.size() ) );
    auto cDP3r_tmp = dst.cDP3r[0];
    dst.cDP3r[0] = src.cDP3r[0];
    dst.cDP3r.push_back(cDP3r_tmp);
    assert(dst.cDP21f.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cDP21f", dst.cDP21f.size() ) );
    assert(src.cDP21f.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cDP21f", src.cDP21f.size() ) );
    auto cDP21f_tmp = dst.cDP21f[0];
    dst.cDP21f[0] = src.cDP21f[0];
    dst.cDP21f.push_back(cDP21f_tmp);
    assert(dst.cDP21r.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cDP21r", dst.cDP21r.size() ) );
    assert(src.cDP21r.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cDP21r", src.cDP21r.size() ) );
    auto cDP21r_tmp = dst.cDP21r[0];
    dst.cDP21r[0] = src.cDP21r[0];
    dst.cDP21r.push_back(cDP21r_tmp);
    assert(dst.cDPMf.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cDPMf", dst.cDPMf.size() ) );
    assert(src.cDPMf.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cDPMf", src.cDPMf.size() ) );
    auto cDPMf_tmp = dst.cDPMf[0];
    dst.cDPMf[0] = src.cDPMf[0];
    dst.cDPMf.push_back(cDPMf_tmp);
    assert(dst.cDPMr.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cDPMr", dst.cDPMr.size() ) );
    assert(src.cDPMr.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cDPMr", src.cDPMr.size() ) );
    auto cDPMr_tmp = dst.cDPMr[0];
    dst.cDPMr[0] = src.cDPMr[0];
    dst.cDPMr.push_back(cDPMr_tmp);
    assert(dst.cDPmf.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cDPmf", dst.cDPmf.size() ) );
    assert(src.cDPmf.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cDPmf", src.cDPmf.size() ) );
    auto cDPmf_tmp = dst.cDPmf[0];
    dst.cDPmf[0] = src.cDPmf[0];
    dst.cDPmf.push_back(cDPmf_tmp);
    assert(dst.cDPmr.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cDPmr", dst.cDPmr.size() ) );
    assert(src.cDPmr.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cDPmr", src.cDPmr.size() ) );
    auto cDPmr_tmp = dst.cDPmr[0];
    dst.cDPmr[0] = src.cDPmr[0];
    dst.cDPmr.push_back(cDPmr_tmp);
    assert(dst.cDPDf.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cDPDf", dst.cDPDf.size() ) );
    assert(src.cDPDf.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cDPDf", src.cDPDf.size() ) );
    auto cDPDf_tmp = dst.cDPDf[0];
    dst.cDPDf[0] = src.cDPDf[0];
    dst.cDPDf.push_back(cDPDf_tmp);
    assert(dst.cDPDr.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cDPDr", dst.cDPDr.size() ) );
    assert(src.cDPDr.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cDPDr", src.cDPDr.size() ) );
    auto cDPDr_tmp = dst.cDPDr[0];
    dst.cDPDr[0] = src.cDPDr[0];
    dst.cDPDr.push_back(cDPDr_tmp);
    assert(dst.dDP1.size() == 1 || !fprintf(stderr, "%lu == 1 failed for dDP1", dst.dDP1.size() ) );
    assert(src.dDP1.size() == 1 || !fprintf(stderr, "%lu == 1 failed for dDP1", src.dDP1.size() ) );
    auto dDP1_tmp = dst.dDP1[0];
    dst.dDP1[0] = src.dDP1[0];
    dst.dDP1.push_back(dDP1_tmp);
    assert(dst.dDP2.size() == 1 || !fprintf(stderr, "%lu == 1 failed for dDP2", dst.dDP2.size() ) );
    assert(src.dDP2.size() == 1 || !fprintf(stderr, "%lu == 1 failed for dDP2", src.dDP2.size() ) );
    auto dDP2_tmp = dst.dDP2[0];
    dst.dDP2[0] = src.dDP2[0];
    dst.dDP2.push_back(dDP2_tmp);
    assert(dst.aBQ.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aBQ", dst.aBQ.size() ) );
    assert(src.aBQ.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aBQ", src.aBQ.size() ) );
    auto aBQ_tmp = dst.aBQ[0];
    dst.aBQ[0] = src.aBQ[0];
    dst.aBQ.push_back(aBQ_tmp);
    assert(dst.a2BQf.size() == 1 || !fprintf(stderr, "%lu == 1 failed for a2BQf", dst.a2BQf.size() ) );
    assert(src.a2BQf.size() == 1 || !fprintf(stderr, "%lu == 1 failed for a2BQf", src.a2BQf.size() ) );
    auto a2BQf_tmp = dst.a2BQf[0];
    dst.a2BQf[0] = src.a2BQf[0];
    dst.a2BQf.push_back(a2BQf_tmp);
    assert(dst.a2BQr.size() == 1 || !fprintf(stderr, "%lu == 1 failed for a2BQr", dst.a2BQr.size() ) );
    assert(src.a2BQr.size() == 1 || !fprintf(stderr, "%lu == 1 failed for a2BQr", src.a2BQr.size() ) );
    auto a2BQr_tmp = dst.a2BQr[0];
    dst.a2BQr[0] = src.a2BQr[0];
    dst.a2BQr.push_back(a2BQr_tmp);
    assert(dst.a2XM2.size() == 1 || !fprintf(stderr, "%lu == 1 failed for a2XM2", dst.a2XM2.size() ) );
    assert(src.a2XM2.size() == 1 || !fprintf(stderr, "%lu == 1 failed for a2XM2", src.a2XM2.size() ) );
    auto a2XM2_tmp = dst.a2XM2[0];
    dst.a2XM2[0] = src.a2XM2[0];
    dst.a2XM2.push_back(a2XM2_tmp);
    assert(dst.a2BM2.size() == 1 || !fprintf(stderr, "%lu == 1 failed for a2BM2", dst.a2BM2.size() ) );
    assert(src.a2BM2.size() == 1 || !fprintf(stderr, "%lu == 1 failed for a2BM2", src.a2BM2.size() ) );
    auto a2BM2_tmp = dst.a2BM2[0];
    dst.a2BM2[0] = src.a2BM2[0];
    dst.a2BM2.push_back(a2BM2_tmp);
    assert(dst.aBQQ.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aBQQ", dst.aBQQ.size() ) );
    assert(src.aBQQ.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aBQQ", src.aBQQ.size() ) );
    auto aBQQ_tmp = dst.aBQQ[0];
    dst.aBQQ[0] = src.aBQQ[0];
    dst.aBQQ.push_back(aBQQ_tmp);
    assert(dst.bMQ.size() == 1 || !fprintf(stderr, "%lu == 1 failed for bMQ", dst.bMQ.size() ) );
    assert(src.bMQ.size() == 1 || !fprintf(stderr, "%lu == 1 failed for bMQ", src.bMQ.size() ) );
    auto bMQ_tmp = dst.bMQ[0];
    dst.bMQ[0] = src.bMQ[0];
    dst.bMQ.push_back(bMQ_tmp);
    assert(dst.aAaMQ.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aAaMQ", dst.aAaMQ.size() ) );
    assert(src.aAaMQ.size() == 1 || !fprintf(stderr, "%lu == 1 failed for aAaMQ", src.aAaMQ.size() ) );
    auto aAaMQ_tmp = dst.aAaMQ[0];
    dst.aAaMQ[0] = src.aAaMQ[0];
    dst.aAaMQ.push_back(aAaMQ_tmp);
    assert(dst.bNMQ.size() == 1 || !fprintf(stderr, "%lu == 1 failed for bNMQ", dst.bNMQ.size() ) );
    assert(src.bNMQ.size() == 1 || !fprintf(stderr, "%lu == 1 failed for bNMQ", src.bNMQ.size() ) );
    auto bNMQ_tmp = dst.bNMQ[0];
    dst.bNMQ[0] = src.bNMQ[0];
    dst.bNMQ.push_back(bNMQ_tmp);
    assert(dst.bNMa.size() == 1 || !fprintf(stderr, "%lu == 1 failed for bNMa", dst.bNMa.size() ) );
    assert(src.bNMa.size() == 1 || !fprintf(stderr, "%lu == 1 failed for bNMa", src.bNMa.size() ) );
    auto bNMa_tmp = dst.bNMa[0];
    dst.bNMa[0] = src.bNMa[0];
    dst.bNMa.push_back(bNMa_tmp);
    assert(dst.bNMb.size() == 1 || !fprintf(stderr, "%lu == 1 failed for bNMb", dst.bNMb.size() ) );
    assert(src.bNMb.size() == 1 || !fprintf(stderr, "%lu == 1 failed for bNMb", src.bNMb.size() ) );
    auto bNMb_tmp = dst.bNMb[0];
    dst.bNMb[0] = src.bNMb[0];
    dst.bNMb.push_back(bNMb_tmp);
    assert(dst.bMQQ.size() == 1 || !fprintf(stderr, "%lu == 1 failed for bMQQ", dst.bMQQ.size() ) );
    assert(src.bMQQ.size() == 1 || !fprintf(stderr, "%lu == 1 failed for bMQQ", src.bMQQ.size() ) );
    auto bMQQ_tmp = dst.bMQQ[0];
    dst.bMQQ[0] = src.bMQQ[0];
    dst.bMQQ.push_back(bMQQ_tmp);
    assert(dst.bIAQb.size() == 1 || !fprintf(stderr, "%lu == 1 failed for bIAQb", dst.bIAQb.size() ) );
    assert(src.bIAQb.size() == 1 || !fprintf(stderr, "%lu == 1 failed for bIAQb", src.bIAQb.size() ) );
    auto bIAQb_tmp = dst.bIAQb[0];
    dst.bIAQb[0] = src.bIAQb[0];
    dst.bIAQb.push_back(bIAQb_tmp);
    assert(dst.bIADb.size() == 1 || !fprintf(stderr, "%lu == 1 failed for bIADb", dst.bIADb.size() ) );
    assert(src.bIADb.size() == 1 || !fprintf(stderr, "%lu == 1 failed for bIADb", src.bIADb.size() ) );
    auto bIADb_tmp = dst.bIADb[0];
    dst.bIADb[0] = src.bIADb[0];
    dst.bIADb.push_back(bIADb_tmp);
    assert(dst.bIDQb.size() == 1 || !fprintf(stderr, "%lu == 1 failed for bIDQb", dst.bIDQb.size() ) );
    assert(src.bIDQb.size() == 1 || !fprintf(stderr, "%lu == 1 failed for bIDQb", src.bIDQb.size() ) );
    auto bIDQb_tmp = dst.bIDQb[0];
    dst.bIDQb[0] = src.bIDQb[0];
    dst.bIDQb.push_back(bIDQb_tmp);
    assert(dst.cIAQf.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cIAQf", dst.cIAQf.size() ) );
    assert(src.cIAQf.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cIAQf", src.cIAQf.size() ) );
    auto cIAQf_tmp = dst.cIAQf[0];
    dst.cIAQf[0] = src.cIAQf[0];
    dst.cIAQf.push_back(cIAQf_tmp);
    assert(dst.cIADf.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cIADf", dst.cIADf.size() ) );
    assert(src.cIADf.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cIADf", src.cIADf.size() ) );
    auto cIADf_tmp = dst.cIADf[0];
    dst.cIADf[0] = src.cIADf[0];
    dst.cIADf.push_back(cIADf_tmp);
    assert(dst.cIDQf.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cIDQf", dst.cIDQf.size() ) );
    assert(src.cIDQf.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cIDQf", src.cIDQf.size() ) );
    auto cIDQf_tmp = dst.cIDQf[0];
    dst.cIDQf[0] = src.cIDQf[0];
    dst.cIDQf.push_back(cIDQf_tmp);
    assert(dst.cIAQr.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cIAQr", dst.cIAQr.size() ) );
    assert(src.cIAQr.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cIAQr", src.cIAQr.size() ) );
    auto cIAQr_tmp = dst.cIAQr[0];
    dst.cIAQr[0] = src.cIAQr[0];
    dst.cIAQr.push_back(cIAQr_tmp);
    assert(dst.cIADr.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cIADr", dst.cIADr.size() ) );
    assert(src.cIADr.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cIADr", src.cIADr.size() ) );
    auto cIADr_tmp = dst.cIADr[0];
    dst.cIADr[0] = src.cIADr[0];
    dst.cIADr.push_back(cIADr_tmp);
    assert(dst.cIDQr.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cIDQr", dst.cIDQr.size() ) );
    assert(src.cIDQr.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cIDQr", src.cIDQr.size() ) );
    auto cIDQr_tmp = dst.cIDQr[0];
    dst.cIDQr[0] = src.cIDQr[0];
    dst.cIDQr.push_back(cIDQr_tmp);
    assert(dst.bIAQ.size() == 1 || !fprintf(stderr, "%lu == 1 failed for bIAQ", dst.bIAQ.size() ) );
    assert(src.bIAQ.size() == 1 || !fprintf(stderr, "%lu == 1 failed for bIAQ", src.bIAQ.size() ) );
    auto bIAQ_tmp = dst.bIAQ[0];
    dst.bIAQ[0] = src.bIAQ[0];
    dst.bIAQ.push_back(bIAQ_tmp);
    assert(dst.cIAQ.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cIAQ", dst.cIAQ.size() ) );
    assert(src.cIAQ.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cIAQ", src.cIAQ.size() ) );
    auto cIAQ_tmp = dst.cIAQ[0];
    dst.cIAQ[0] = src.cIAQ[0];
    dst.cIAQ.push_back(cIAQ_tmp);
    assert(dst.bTINQ.size() == 1 || !fprintf(stderr, "%lu == 1 failed for bTINQ", dst.bTINQ.size() ) );
    assert(src.bTINQ.size() == 1 || !fprintf(stderr, "%lu == 1 failed for bTINQ", src.bTINQ.size() ) );
    auto bTINQ_tmp = dst.bTINQ[0];
    dst.bTINQ[0] = src.bTINQ[0];
    dst.bTINQ.push_back(bTINQ_tmp);
    assert(dst.cTINQ.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cTINQ", dst.cTINQ.size() ) );
    assert(src.cTINQ.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cTINQ", src.cTINQ.size() ) );
    auto cTINQ_tmp = dst.cTINQ[0];
    dst.cTINQ[0] = src.cTINQ[0];
    dst.cTINQ.push_back(cTINQ_tmp);
    assert(dst.cPCQ1.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cPCQ1", dst.cPCQ1.size() ) );
    assert(src.cPCQ1.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cPCQ1", src.cPCQ1.size() ) );
    auto cPCQ1_tmp = dst.cPCQ1[0];
    dst.cPCQ1[0] = src.cPCQ1[0];
    dst.cPCQ1.push_back(cPCQ1_tmp);
    assert(dst.cPLQ1.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cPLQ1", dst.cPLQ1.size() ) );
    assert(src.cPLQ1.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cPLQ1", src.cPLQ1.size() ) );
    auto cPLQ1_tmp = dst.cPLQ1[0];
    dst.cPLQ1[0] = src.cPLQ1[0];
    dst.cPLQ1.push_back(cPLQ1_tmp);
    assert(dst.cVQ1.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cVQ1", dst.cVQ1.size() ) );
    assert(src.cVQ1.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cVQ1", src.cVQ1.size() ) );
    auto cVQ1_tmp = dst.cVQ1[0];
    dst.cVQ1[0] = src.cVQ1[0];
    dst.cVQ1.push_back(cVQ1_tmp);
    assert(dst.gVQ1.size() == 1 || !fprintf(stderr, "%lu == 1 failed for gVQ1", dst.gVQ1.size() ) );
    assert(src.gVQ1.size() == 1 || !fprintf(stderr, "%lu == 1 failed for gVQ1", src.gVQ1.size() ) );
    auto gVQ1_tmp = dst.gVQ1[0];
    dst.gVQ1[0] = src.gVQ1[0];
    dst.gVQ1.push_back(gVQ1_tmp);
    assert(dst.cPCQ2.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cPCQ2", dst.cPCQ2.size() ) );
    assert(src.cPCQ2.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cPCQ2", src.cPCQ2.size() ) );
    auto cPCQ2_tmp = dst.cPCQ2[0];
    dst.cPCQ2[0] = src.cPCQ2[0];
    dst.cPCQ2.push_back(cPCQ2_tmp);
    assert(dst.cPLQ2.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cPLQ2", dst.cPLQ2.size() ) );
    assert(src.cPLQ2.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cPLQ2", src.cPLQ2.size() ) );
    auto cPLQ2_tmp = dst.cPLQ2[0];
    dst.cPLQ2[0] = src.cPLQ2[0];
    dst.cPLQ2.push_back(cPLQ2_tmp);
    assert(dst.cVQ2.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cVQ2", dst.cVQ2.size() ) );
    assert(src.cVQ2.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cVQ2", src.cVQ2.size() ) );
    auto cVQ2_tmp = dst.cVQ2[0];
    dst.cVQ2[0] = src.cVQ2[0];
    dst.cVQ2.push_back(cVQ2_tmp);
    assert(dst.cMmQ.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cMmQ", dst.cMmQ.size() ) );
    assert(src.cMmQ.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cMmQ", src.cMmQ.size() ) );
    auto cMmQ_tmp = dst.cMmQ[0];
    dst.cMmQ[0] = src.cMmQ[0];
    dst.cMmQ.push_back(cMmQ_tmp);
    assert(dst.dVQinc.size() == 1 || !fprintf(stderr, "%lu == 1 failed for dVQinc", dst.dVQinc.size() ) );
    assert(src.dVQinc.size() == 1 || !fprintf(stderr, "%lu == 1 failed for dVQinc", src.dVQinc.size() ) );
    auto dVQinc_tmp = dst.dVQinc[0];
    dst.dVQinc[0] = src.dVQinc[0];
    dst.dVQinc.push_back(dVQinc_tmp);
    assert(dst.cDP1v.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cDP1v", dst.cDP1v.size() ) );
    assert(src.cDP1v.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cDP1v", src.cDP1v.size() ) );
    auto cDP1v_tmp = dst.cDP1v[0];
    dst.cDP1v[0] = src.cDP1v[0];
    dst.cDP1v.push_back(cDP1v_tmp);
    assert(dst.cDP1w.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cDP1w", dst.cDP1w.size() ) );
    assert(src.cDP1w.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cDP1w", src.cDP1w.size() ) );
    auto cDP1w_tmp = dst.cDP1w[0];
    dst.cDP1w[0] = src.cDP1w[0];
    dst.cDP1w.push_back(cDP1w_tmp);
    assert(dst.cDP1x.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cDP1x", dst.cDP1x.size() ) );
    assert(src.cDP1x.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cDP1x", src.cDP1x.size() ) );
    auto cDP1x_tmp = dst.cDP1x[0];
    dst.cDP1x[0] = src.cDP1x[0];
    dst.cDP1x.push_back(cDP1x_tmp);
    assert(dst.cDP2v.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cDP2v", dst.cDP2v.size() ) );
    assert(src.cDP2v.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cDP2v", src.cDP2v.size() ) );
    auto cDP2v_tmp = dst.cDP2v[0];
    dst.cDP2v[0] = src.cDP2v[0];
    dst.cDP2v.push_back(cDP2v_tmp);
    assert(dst.cDP2w.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cDP2w", dst.cDP2w.size() ) );
    assert(src.cDP2w.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cDP2w", src.cDP2w.size() ) );
    auto cDP2w_tmp = dst.cDP2w[0];
    dst.cDP2w[0] = src.cDP2w[0];
    dst.cDP2w.push_back(cDP2w_tmp);
    assert(dst.cDP2x.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cDP2x", dst.cDP2x.size() ) );
    assert(src.cDP2x.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cDP2x", src.cDP2x.size() ) );
    auto cDP2x_tmp = dst.cDP2x[0];
    dst.cDP2x[0] = src.cDP2x[0];
    dst.cDP2x.push_back(cDP2x_tmp);
    assert(dst.CONTQ.size() == 1 || !fprintf(stderr, "%lu == 1 failed for CONTQ", dst.CONTQ.size() ) );
    assert(src.CONTQ.size() == 1 || !fprintf(stderr, "%lu == 1 failed for CONTQ", src.CONTQ.size() ) );
    auto CONTQ_tmp = dst.CONTQ[0];
    dst.CONTQ[0] = src.CONTQ[0];
    dst.CONTQ.push_back(CONTQ_tmp);
    assert(dst.VTI.size() == 1 || !fprintf(stderr, "%lu == 1 failed for VTI", dst.VTI.size() ) );
    assert(src.VTI.size() == 1 || !fprintf(stderr, "%lu == 1 failed for VTI", src.VTI.size() ) );
    auto VTI_tmp = dst.VTI[0];
    dst.VTI[0] = src.VTI[0];
    dst.VTI.push_back(VTI_tmp);
    assert(dst.VTD.size() == 1 || !fprintf(stderr, "%lu == 1 failed for VTD", dst.VTD.size() ) );
    assert(src.VTD.size() == 1 || !fprintf(stderr, "%lu == 1 failed for VTD", src.VTD.size() ) );
    auto VTD_tmp = dst.VTD[0];
    dst.VTD[0] = src.VTD[0];
    dst.VTD.push_back(VTD_tmp);
    assert(dst.bDPa.size() == 1 || !fprintf(stderr, "%lu == 1 failed for bDPa", dst.bDPa.size() ) );
    assert(src.bDPa.size() == 1 || !fprintf(stderr, "%lu == 1 failed for bDPa", src.bDPa.size() ) );
    auto bDPa_tmp = dst.bDPa[0];
    dst.bDPa[0] = src.bDPa[0];
    dst.bDPa.push_back(bDPa_tmp);
    assert(dst.cDP0a.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cDP0a", dst.cDP0a.size() ) );
    assert(src.cDP0a.size() == 1 || !fprintf(stderr, "%lu == 1 failed for cDP0a", src.cDP0a.size() ) );
    auto cDP0a_tmp = dst.cDP0a[0];
    dst.cDP0a[0] = src.cDP0a[0];
    dst.cDP0a.push_back(cDP0a_tmp);
    assert(dst.gapSa.size() == 1 || !fprintf(stderr, "%lu == 1 failed for gapSa", dst.gapSa.size() ) );
    assert(src.gapSa.size() == 1 || !fprintf(stderr, "%lu == 1 failed for gapSa", src.gapSa.size() ) );
    auto gapSa_tmp = dst.gapSa[0];
    dst.gapSa[0] = src.gapSa[0];
    dst.gapSa.push_back(gapSa_tmp);

    return 0;};
const char *const FORMAT_LINES[] = {
    "##FORMAT=<ID=GT,Number=1,Type=String,Description=\"Genotype (for tumor cells, this is only a guess)\">",
    "##FORMAT=<ID=GQ,Number=1,Type=Integer,Description=\"Genotype Quality. \">",
    "##FORMAT=<ID=HQ,Number=2,Type=Integer,Description=\"Haplotype Quality. \">",
    "##FORMAT=<ID=FT,Number=1,Type=String,Description=\"Sample genotype filter indicating if this genotype was 'called' (similar in concept to the FILTER field). Again, use PASS to indicate that all filters have been passed, a semi-colon separated list of codes for filters that fail, or ‘.’ to indicate that filters have not been applied. These values should be described in the meta-information in the same way as FILTERs (String, no white-space or semi-colons permitted)\">",
    "##FORMAT=<ID=FTS,Number=A,Type=String,Description=\"Sample variant filter indicating if this variant was 'called' (similar in concept to the FILTER field). Again, use PASS to indicate that all filters have been passed, a vertical bar (|)-separated list of codes for filters that fail, or '.' to indicate that filters have not been applied. These values should be described in the meta-information in the same way as FILTERs. No white-space, semi-colons, or vertical bar (|) permitted. \">",
    "##FORMAT=<ID=_A_,Number=1,Type=String,Description=\"SUB-HEADER: Summary statistics. \">",
    "##FORMAT=<ID=DP,Number=1,Type=Integer,Description=\"Fragment depth of coverage with duplicates removed. \">",
    "##FORMAT=<ID=AD,Number=R,Type=Integer,Description=\"Fragment depth supporting the ALT allele with duplicates removed. \">",
    "##FORMAT=<ID=bDP,Number=1,Type=Integer,Description=\"Fragment depth of coverage with duplicates kept. \">",
    "##FORMAT=<ID=bAD,Number=R,Type=Integer,Description=\"Fragment depth supporting the ALT allele with duplicates kept. \">",
    "##FORMAT=<ID=c2DP,Number=1,Type=Integer,Description=\"Consensus UMI-barcode family depth of coverage using tier-2 thresholds for grouping fragments into families. \">",
    "##FORMAT=<ID=c2AD,Number=R,Type=Integer,Description=\"Consensus UMI_barcode family depth of coverage supporting the ALT allele using tier-2 thresholds for grouping fragments into families. \">",
    "##FORMAT=<ID=_Aa,Number=1,Type=String,Description=\"SUB-HEADER: Preparation statistics for segment biases at this position. \">",
    "##FORMAT=<ID=APDP,Number=12,Type=Integer,Description=\"Read segment sequencing depths with the following characteristics: total (1), within the InDel length of insertion (2) and deletion (3), within the tandem-repeat track length of insertion (4) and deletion (5), originated from PCR amplicons (6), of SNV (7), of DNV (8), of high quality (9), near-clip (10), supported by confident alignments which have no long InDels and no long clips (11), and UMI (unique molecular identifier, a.k.a. molecular barcode)-labeled (12). \">",
    "##FORMAT=<ID=APXM,Number=8,Type=Integer,Description=\"Expected number of mismatches (1) and gap openings (2) in a 1500-bp window. Total sum of query length (3). Total sum of average InDel length of each sequenced segment (4). The (sum of squares (5,6)) and (sum of 100 divided by (7,8)) of insertion (5,7) and deletion (6,8) lengths. \">",
    "##FORMAT=<ID=_Ab,Number=1,Type=String,Description=\"SUB-HEADER: Preparation statistics for segment biases at this position. \">",
    "##FORMAT=<ID=APLRID,Number=4,Type=Integer,Description=\"Summed squared insertion (1,2) and deletion (3,4) lengths to the left (1,3) and right (2,4) ends of the InDel-affected region. \">",
    "##FORMAT=<ID=APLRI,Number=4,Type=Integer,Description=\"Summed distance to left insert end and the number of such inserts, and similarly for right insert end. \">",
    "##FORMAT=<ID=APLRP,Number=4,Type=Integer,Description=\"Summed distance to left and right ends, summed insertion length, and summed deletion length. \">",
    "##FORMAT=<ID=_Ac,Number=1,Type=String,Description=\"SUB-HEADER: Threshold for each type of bias (tier-1 means weak bias and tier-2 means strong bias). \">",
    "##FORMAT=<ID=ALRPxT,Number=2,Type=Integer,Description=\"Number of bases to left (1,2) and right (3.4) segment ends above which the segment is not used for computing position bias. \">",
    "##FORMAT=<ID=ALRIT,Number=4,Type=Integer,Description=\"Number of bases to left (1,2) and right (3.4) insert ends above which there is tier-1 and tier-2 insert bias. \">",
    "##FORMAT=<ID=ALRIt,Number=4,Type=Integer,Description=\"Number of bases to left (1,2) and right (3,4) insert ends below which there is tier-1 and tier-2 insert bias. \">",
    "##FORMAT=<ID=ALRPt,Number=4,Type=Integer,Description=\"Number of bases to left (1,2) and right (3,4) read-segment ends below which there is tier-1 and tier-2 position bias. \">",
    "##FORMAT=<ID=ALRBt,Number=4,Type=Integer,Description=\"Base alignment quality (BAQ) to left (1,2) and right (3,4) read-segment ends below which there is tier-1 and tier-2 position bias. \">",
    "##FORMAT=<ID=_AQ,Number=1,Type=String,Description=\"SUB-HEADER: Sum of qualities (For FORMAT/TAG with the prefixes '_A', '_B', '_C', or '_D' in the SUB-HEADER without checking whether the first letter is in upper or lower case, the TAG values are for REF/ALT if Number=R (i.e., starting with the letter A, B, C or D), all alleles by sum if Number=1 (i.e., starting with the letter a, b, c or d), and all-alleles by sum/the padded deletion allele if Number=2 (i.e., starting with a, b, c or d)). The f, r, and b letter suffixes mean forward, reverse, and both directions, respectively. \">",
    "##FORMAT=<ID=aMQs,Number=R,Type=Integer,Description=\"Raw sequencing segment sum of mapping qualities for the REF and ALT alleles. \">",
    "##FORMAT=<ID=AMQs,Number=1,Type=Integer,Description=\"Raw sequencing segment sum of mapping qualities for all alleles by sum and the padded deletion. \">",
    "##FORMAT=<ID=a1BQf,Number=R,Type=Integer,Description=\"Raw sequencing-segment sum of base quality on the forward strand. \">",
    "##FORMAT=<ID=A1BQf,Number=1,Type=Integer,Description=\"Raw sequencing-segment sum of base quality on the forward strand. \">",
    "##FORMAT=<ID=a1BQr,Number=R,Type=Integer,Description=\"Raw sequencing-segment sum of base quality on the reverse strand. \">",
    "##FORMAT=<ID=A1BQr,Number=1,Type=Integer,Description=\"Raw sequencing-segment sum of base quality on the reverse strand. \">",
    "##FORMAT=<ID=_ADPf,Number=1,Type=String,Description=\"SUB-HEADER: Raw sequencing segment depths with forward orientation. \">",
    "##FORMAT=<ID=aDPff,Number=R,Type=Integer,Description=\"Raw sequencing segment depth with the R1-forward orientation and strand. \">",
    "##FORMAT=<ID=ADPff,Number=2,Type=Integer,Description=\"Raw sequencing segment depth with the R1-forward orientation and strand. \">",
    "##FORMAT=<ID=aDPfr,Number=R,Type=Integer,Description=\"Raw sequencing segment depth with the R2-reverse orientation and strand. \">",
    "##FORMAT=<ID=ADPfr,Number=2,Type=Integer,Description=\"Raw sequencing segment depth with the R2-reverse orientation and strand. \">",
    "##FORMAT=<ID=_ADPr,Number=1,Type=String,Description=\"SUB-HEADER: Raw sequencing segment depths with reverse orientation. \">",
    "##FORMAT=<ID=aDPrf,Number=R,Type=Integer,Description=\"Raw sequencing segment depth with the R2-forward orientation and strand. \">",
    "##FORMAT=<ID=ADPrf,Number=2,Type=Integer,Description=\"Raw sequencing segment depth with the R2-forward orientation and strand. \">",
    "##FORMAT=<ID=aDPrr,Number=R,Type=Integer,Description=\"Raw sequencing segment depth with the R1-reverse orientation and strand. \">",
    "##FORMAT=<ID=ADPrr,Number=2,Type=Integer,Description=\"Raw sequencing segment depth with the R1-reverse orientation and strand. \">",
    "##FORMAT=<ID=_ALP,Number=1,Type=String,Description=\"SUB-HEADER: Raw sequencing segment statistics related to position bias on the left side. \">",
    "##FORMAT=<ID=aLP1,Number=R,Type=Integer,Description=\"Raw sequencing segment depth unaffected by tier-1 left-side position bias. \">",
    "##FORMAT=<ID=ALP1,Number=1,Type=Integer,Description=\"Raw sequencing segment depth unaffected by tier-1 left-side position bias. \">",
    "##FORMAT=<ID=aLP2,Number=R,Type=Integer,Description=\"Raw sequencing segment depth unaffected by tier-2 left-side position bias. \">",
    "##FORMAT=<ID=ALP2,Number=1,Type=Integer,Description=\"Raw sequencing segment depth unaffected by tier-2 left-side position bias. \">",
    "##FORMAT=<ID=aLPL,Number=R,Type=Integer,Description=\"Raw summed distance (number of bases) to the left-side sequencing-segment end using only high-quality bases far from alignment ends. \">",
    "##FORMAT=<ID=ALPL,Number=1,Type=Integer,Description=\"Raw summed distance (number of bases) to the left-side sequencing-segment end using only high-quality bases far from alignment ends. \">",
    "##FORMAT=<ID=_ARP,Number=1,Type=String,Description=\"SUB-HEADER: Raw sequencing segment statistics related to position bias on the right side. \">",
    "##FORMAT=<ID=aRP1,Number=R,Type=Integer,Description=\"Raw sequencing segment depth unaffected by tier-1 right-side position bias. \">",
    "##FORMAT=<ID=ARP1,Number=1,Type=Integer,Description=\"Raw sequencing segment depth unaffected by tier-1 right-side position bias. \">",
    "##FORMAT=<ID=aRP2,Number=R,Type=Integer,Description=\"Raw sequencing segment depth unaffected by tier-2 right-side position bias. \">",
    "##FORMAT=<ID=ARP2,Number=1,Type=Integer,Description=\"Raw sequencing segment depth unaffected by tier-2 right-side position bias. \">",
    "##FORMAT=<ID=aRPL,Number=R,Type=Integer,Description=\"Raw summed distance (number of bases) to the right-side sequencing-segment end using only high-quality bases far from alignment ends. \">",
    "##FORMAT=<ID=ARPL,Number=1,Type=Integer,Description=\"Raw summed distance (number of bases) to the right-side sequencing-segment end using only high-quality bases far from alignment ends. \">",
    "##FORMAT=<ID=_ALB,Number=1,Type=String,Description=\"SUB-HEADER: Raw sequencing segment statistics related to base-alignment-quality (BAQ) bias on the left side. \">",
    "##FORMAT=<ID=aLB1,Number=R,Type=Integer,Description=\"Raw sequencing segment depth unaffected by tier-1 left-side base-alignment bias. \">",
    "##FORMAT=<ID=aLB2,Number=R,Type=Integer,Description=\"Raw sequencing segment depth unaffected by tier-2 left-side base-alignment bias. \">",
    "##FORMAT=<ID=ALB2,Number=1,Type=Integer,Description=\"Raw sequencing segment depth unaffected by tier-2 left-side position bias. \">",
    "##FORMAT=<ID=aLBL,Number=R,Type=Integer,Description=\"Raw summed BAQ (base-alignment quality) to the left-side sequencing-segment end. \">",
    "##FORMAT=<ID=ALBL,Number=1,Type=Integer,Description=\"Raw summed distance (number of bases) to the left-side sequencing-segment end. \">",
    "##FORMAT=<ID=_ARB,Number=1,Type=String,Description=\"SUB-HEADER: Raw sequencing segment statistics related to base-alignment-quality (BAQ) bias on the right side. \">",
    "##FORMAT=<ID=aRB1,Number=R,Type=Integer,Description=\"Raw sequencing segment depth unaffected by tier-1 right-side base-alignment bias. \">",
    "##FORMAT=<ID=aRB2,Number=R,Type=Integer,Description=\"Raw sequencing segment depth unaffected by tier-2 right-side base-alignment bias. \">",
    "##FORMAT=<ID=ARB2,Number=1,Type=Integer,Description=\"Raw sequencing segment depth unaffected by tier-2 right-side position bias. \">",
    "##FORMAT=<ID=aRBL,Number=R,Type=Integer,Description=\"Raw summed BAQ (base-alignment quality) to the right-side sequencing-segment end. \">",
    "##FORMAT=<ID=ARBL,Number=1,Type=Integer,Description=\"Raw summed distance (number of bases) to the right-side sequencing-segment end. \">",
    "##FORMAT=<ID=_ALI,Number=1,Type=String,Description=\"SUB-HEADER: Raw sequencing segment statistics related to insert-end bias on the left side. \">",
    "##FORMAT=<ID=aLI1,Number=R,Type=Integer,Description=\"Raw sequencing segment depth unaffected by tier-1 insert bias on the left side. \">",
    "##FORMAT=<ID=aLI2,Number=R,Type=Integer,Description=\"Raw sequencing segment depth unaffected by tier-2 insert bias on the left side. \">",
    "##FORMAT=<ID=ALI2,Number=1,Type=Integer,Description=\"Raw sequencing segment depth unaffected by tier-2 insert bias on the left side. \">",
    "##FORMAT=<ID=aLIr,Number=R,Type=Integer,Description=\"Raw sequencing segment depth eligible for left-side reverse-strand bias computation. \">",
    "##FORMAT=<ID=ALIr,Number=1,Type=Integer,Description=\"Raw sequencing segment depth eligible for left-side reverse-strand bias computation. \">",
    "##FORMAT=<ID=_ARI,Number=1,Type=String,Description=\"SUB-HEADER: Raw sequencing segment statistics related to insert-end bias on the right side. \">",
    "##FORMAT=<ID=aRI1,Number=R,Type=Integer,Description=\"Raw sequencing segment depth unaffected by tier-1 insert bias on the right side. \">",
    "##FORMAT=<ID=aRI2,Number=R,Type=Integer,Description=\"Raw sequencing segment depth unaffected by tier-2 insert bias on the right side. \">",
    "##FORMAT=<ID=ARI2,Number=1,Type=Integer,Description=\"Raw sequencing segment depth unaffected by tier-2 insert bias on the right side. \">",
    "##FORMAT=<ID=aRIf,Number=R,Type=Integer,Description=\"Raw sequencing segment depth eligible for right-side forward-strand bias computation. \">",
    "##FORMAT=<ID=ARIf,Number=1,Type=Integer,Description=\"Raw sequencing segment depth eligible for right-side forward-strand bias computation. \">",
    "##FORMAT=<ID=_AX,Number=1,Type=String,Description=\"SUB-HEADER: Raw sequencing segment statistics for extra information. \">",
    "##FORMAT=<ID=aBQ2,Number=R,Type=Integer,Description=\"Raw sequencing segment depth unaffected by tier-2 base quality bias. \">",
    "##FORMAT=<ID=ABQ2,Number=1,Type=Integer,Description=\"Raw sequencing segment depth unaffected by tier-2 base quality bias. \">",
    "##FORMAT=<ID=aPF2,Number=R,Type=Integer,Description=\"Raw sequencing segment depth unaffected by tier-2 relative mismatch bias and base quality bias. \">",
    "##FORMAT=<ID=APF2,Number=1,Type=Integer,Description=\"Raw sequencing segment depth unaffected by tier-2 mismatch bias. \">",
    "##FORMAT=<ID=aP1,Number=R,Type=Integer,Description=\"Raw sequencing segment depth of reads passing left and right number of bases threshold of distance. \">",
    "##FORMAT=<ID=AP1,Number=1,Type=Integer,Description=\"Raw sequencing segment depth of reads passing left and right number of bases threshold of distance. \">",
    "##FORMAT=<ID=aP2,Number=R,Type=Integer,Description=\"Raw sequencing segment depth of reads that are either labeled with UMIs or not coming from PCR amplicons. \">",
    "##FORMAT=<ID=AP2,Number=1,Type=Integer,Description=\"Raw sequencing segment depth of reads that are either labeled with UMIs or not coming from PCR amplicons. \">",
    "##FORMAT=<ID=_Ax,Number=1,Type=String,Description=\"SUB-HEADER: Raw sequencing segment statistics for extra information for only the REF and ALT alleles. \">",
    "##FORMAT=<ID=aPF1,Number=R,Type=Integer,Description=\"Raw sequencing segment depth unaffected by tier-1 relative mismatch bias and base quality bias. \">",
    "##FORMAT=<ID=aLIT,Number=R,Type=Integer,Description=\"Raw summed distance (number of bases) to the left-side insert end. \">",
    "##FORMAT=<ID=aRIT,Number=R,Type=Integer,Description=\"Raw summed distance (number of bases) to the right-side insert end. \">",
    "##FORMAT=<ID=aP3,Number=R,Type=Integer,Description=\"Raw sequencing segment depth of reads that are not affected by nearby InDels. \">",
    "##FORMAT=<ID=aNC,Number=R,Type=Integer,Description=\"Raw sequencing segment depth of reads that do not have any clips (including soft and hard clips). \">",
    "##FORMAT=<ID=_BDP,Number=1,Type=String,Description=\"SUB-HEADER: Non-de-duplicated fragment depth for all alleles by sum and the padded deletion allele. \">",
    "##FORMAT=<ID=bDPf,Number=R,Type=Integer,Description=\"See BDPf. \">",
    "##FORMAT=<ID=bDPr,Number=R,Type=Integer,Description=\"See BDPr. \">",
    "##FORMAT=<ID=BDPb,Number=2,Type=Integer,Description=\"Non-de-duplicated fragment depth on the forward and reverse strands for all alleles by sum. \">",
    "##FORMAT=<ID=BDPd,Number=2,Type=Integer,Description=\"Non-de-duplicated fragment depth on the forward and reverse strands for the padded deletion allele. \">",
    "##FORMAT=<ID=bTAf,Number=R,Type=Integer,Description=\"See BTAf. \">",
    "##FORMAT=<ID=bTAr,Number=R,Type=Integer,Description=\"See BTAr. \">",
    "##FORMAT=<ID=BTAb,Number=2,Type=Integer,Description=\"Non-de-duplicated sum of sequenced fragment positions on the forward and reverse strands for all alleles by sum. \">",
    "##FORMAT=<ID=bTBf,Number=R,Type=Integer,Description=\"See BTBf. \">",
    "##FORMAT=<ID=bTBr,Number=R,Type=Integer,Description=\"See BTBr. \">",
    "##FORMAT=<ID=BTBb,Number=2,Type=Integer,Description=\"Non-de-duplicated sum of sequenced fragment positions near mutations on the forward and reverse strands for all alleles by sum. \">",
    "##FORMAT=<ID=_CDP1,Number=1,Type=String,Description=\"SUB-HEADER: De-duplicated depths of the unique molecular fragments for all alleles by sum and the padded deletion allele. \">",
    "##FORMAT=<ID=cDP1f,Number=R,Type=Integer,Description=\"Non-filtered de-duplicated depth of the unique molecular fragments on the forward read orientation. \">",
    "##FORMAT=<ID=cDP1r,Number=R,Type=Integer,Description=\"Non-filtered de-duplicated depth of the unique molecular fragments on the reverse read orientation. \">",
    "##FORMAT=<ID=CDP1b,Number=2,Type=Integer,Description=\"Non-filtered de-duplicated depth of the unique molecular fragments on the forward and reverse read orientations for all alleles by sum. \">",
    "##FORMAT=<ID=CDP1d,Number=2,Type=Integer,Description=\"Non-filtered de-duplicated depth of the unique molecular fragments on the forward and reverse read orientations for the padded deletion allele. \">",
    "##FORMAT=<ID=cDP12f,Number=R,Type=Integer,Description=\"BQ-filtered de-duplicated depth of the unique molecular fragments on the forward read orientation. \">",
    "##FORMAT=<ID=cDP12r,Number=R,Type=Integer,Description=\"BQ-filtered de-duplicated depth of the unique molecular fragments on the reverse read orientation. \">",
    "##FORMAT=<ID=CDP12b,Number=2,Type=Integer,Description=\"BQ-Filtered de-duplicated depth of the unique molecular fragments on the forward and reverse read orientations. \">",
    "##FORMAT=<ID=_CDP2,Number=1,Type=String,Description=\"SUB-HEADER: Tier-2 single-strand consensus sequence (SSCS) depth. \">",
    "##FORMAT=<ID=cDP2f,Number=R,Type=Integer,Description=\"SSCS depth on the forward read orientation for each allele. \">",
    "##FORMAT=<ID=cDP2r,Number=R,Type=Integer,Description=\"SSCS depth on the reverse read orientation for each allele. \">",
    "##FORMAT=<ID=CDP2b,Number=2,Type=Integer,Description=\"SSCS depth on the forward and reverse read orientations for all alleles by sum. \">",
    "##FORMAT=<ID=CDP2d,Number=2,Type=Integer,Description=\"SSCS depth on the forward and reverse read orientations for the padded deletion allele. \">",
    "##FORMAT=<ID=c2BQ2,Number=R,Type=Integer,Description=\"SSCS depth unaffected by tier-2 base quality bias. \">",
    "##FORMAT=<ID=C2BQ2,Number=1,Type=Integer,Description=\"SSCS depth unaffected by tier-2 base quality bias. \">",
    "##FORMAT=<ID=c2LP0,Number=R,Type=Integer,Description=\"SSCS depth unaffected by strictly defined no-prior left-side position bias. \">",
    "##FORMAT=<ID=C2LP0,Number=1,Type=Integer,Description=\"SSCS depth unaffected by strictly defined no-prior left-side position bias. \">",
    "##FORMAT=<ID=c2RP0,Number=R,Type=Integer,Description=\"SSCS depth unaffected by strictly defined no-prior right-side position bias. \">",
    "##FORMAT=<ID=C2RP0,Number=1,Type=Integer,Description=\"SSCS depth unaffected by strictly defined no-prior right-side position bias. \">",
    "##FORMAT=<ID=_C2XP,Number=1,Type=String,Description=\"SUB-HEADER: SSCS statistics related to position bias. If this tag is present and absent, then all SSCS-related tags are all present and absent, respectively. \">",
    "##FORMAT=<ID=c2LP1,Number=R,Type=Integer,Description=\"SSCS depth unaffected by tier-1 left-side position bias. \">",
    "##FORMAT=<ID=c2LP2,Number=R,Type=Integer,Description=\"SSCS depth unaffected by tier-2 left-side position bias. \">",
    "##FORMAT=<ID=C2LP2,Number=1,Type=Integer,Description=\"SSCS depth unaffected by tier-2 left-side position bias. \">",
    "##FORMAT=<ID=c2RP1,Number=R,Type=Integer,Description=\"SSCS depth unaffected by tier-1 right-side position bias. \">",
    "##FORMAT=<ID=c2RP2,Number=R,Type=Integer,Description=\"SSCS depth unaffected by tier-2 right-side position bias. \">",
    "##FORMAT=<ID=C2RP2,Number=1,Type=Integer,Description=\"SSCS depth unaffected by tier-2 right-side position bias. \">",
    "##FORMAT=<ID=c2LPL,Number=R,Type=Integer,Description=\"Raw summed distance (number of bases) to the left-side tier-2 SSCS end. \">",
    "##FORMAT=<ID=C2LPL,Number=1,Type=Integer,Description=\"Raw summed distance (number of bases) to the left-side tier-2 SSCS end. \">",
    "##FORMAT=<ID=c2RPL,Number=R,Type=Integer,Description=\"Raw summed distance (number of bases) to the right-side tier-2 SSCS end. \">",
    "##FORMAT=<ID=C2RPL,Number=1,Type=Integer,Description=\"Raw summed distance (number of bases) to the right-side tier-2 SSCS end. \">",
    "##FORMAT=<ID=_C2XB,Number=1,Type=String,Description=\"SUB-HEADER: SSCS statistics related to alignment quality bias. \">",
    "##FORMAT=<ID=c2LB1,Number=R,Type=Integer,Description=\"SSCS depth unaffected by tier-1 left-side base-alignment bias. \">",
    "##FORMAT=<ID=c2LB2,Number=R,Type=Integer,Description=\"SSCS depth unaffected by tier-2 left-side base-alignment bias. \">",
    "##FORMAT=<ID=C2LB2,Number=1,Type=Integer,Description=\"SSCS depth unaffected by tier-2 left-side position bias. \">",
    "##FORMAT=<ID=c2RB1,Number=R,Type=Integer,Description=\"SSCS depth unaffected by tier-1 right-side base-alignment bias. \">",
    "##FORMAT=<ID=c2RB2,Number=R,Type=Integer,Description=\"SSCS depth unaffected by tier-2 right-side base-alignment bias. \">",
    "##FORMAT=<ID=C2RB2,Number=1,Type=Integer,Description=\"SSCS depth unaffected by tier-2 right-side position bias. \">",
    "##FORMAT=<ID=c2LBL,Number=R,Type=Integer,Description=\"Raw summed BAQ (base-alignment quality) to the left-side of tier-2 SSCS. \">",
    "##FORMAT=<ID=C2LBL,Number=1,Type=Integer,Description=\"Raw summed BAQ (base-alignment quality) to the left-side of tier-2 SSCS. \">",
    "##FORMAT=<ID=c2RBL,Number=R,Type=Integer,Description=\"Raw summed BAQ (base-alignment quality) to the left-side of tier-2 SSCS. \">",
    "##FORMAT=<ID=C2RBL,Number=1,Type=Integer,Description=\"Raw summed BAQ (base-alignment quality) to the left-side of tier-2 SSCS. \">",
    "##FORMAT=<ID=_CDPx,Number=1,Type=String,Description=\"SUB-HEADER: Other extra tags extracted from single-strand consensus sequences (SSCSs) derived by UMI molecular-barcode families. \">",
    "##FORMAT=<ID=cDP3f,Number=R,Type=Integer,Description=\"Strong SSCS depth on the forward read orientation for each allele. \">",
    "##FORMAT=<ID=cDP3r,Number=R,Type=Integer,Description=\"Strong SSCS depth on the reverse read orientation for each allele. \">",
    "##FORMAT=<ID=CDP3b,Number=2,Type=Integer,Description=\"Strong SSCS depth on the forward and reverse read orientations for all alleles by sum. \">",
    "##FORMAT=<ID=cDP21f,Number=R,Type=Integer,Description=\"SSCS singleton on the forward read orientation. \">",
    "##FORMAT=<ID=cDP21r,Number=R,Type=Integer,Description=\"SSCS singleton on the reverse read orientation. \">",
    "##FORMAT=<ID=CDP21b,Number=2,Type=Integer,Description=\"SSCS singleton on the forward and reverse read orientations for all alleles by sum. \">",
    "##FORMAT=<ID=_cDPMm,Number=1,Type=String,Description=\"SUB-HEADER: Empirical PCR-fragment (with dups) error in SSCS UMI-families used to estimate base-call-like qualities. \">",
    "##FORMAT=<ID=cDPMf,Number=R,Type=Integer,Description=\"Depth of PCR fragments supporting the UMI-consensus allele on the forward read orientation for each allele. \">",
    "##FORMAT=<ID=cDPMr,Number=R,Type=Integer,Description=\"Depth of PCR fragments supporting the UMI-consensus allele on the reverse read orientation for each allele. \">",
    "##FORMAT=<ID=CDPMb,Number=2,Type=Integer,Description=\"Depth of PCR fragments supporting the UMI-consensus allele on the forward and reverse read orientations for all alleles by sum. \">",
    "##FORMAT=<ID=cDPmf,Number=R,Type=Integer,Description=\"Depth of PCR fragments not supporting the UMI-consensus allele on the forward read orientation for each allele. \">",
    "##FORMAT=<ID=cDPmr,Number=R,Type=Integer,Description=\"Depth of PCR fragments not supporting the UMI-consensus allele on the reverse read orientation for each allele. \">",
    "##FORMAT=<ID=CDPmb,Number=2,Type=Integer,Description=\"Depth of PCR fragments not supporting the UMI-consensus allele on the forward and reverse read orientations for all alleles by sum. \">",
    "##FORMAT=<ID=CDPDb,Number=2,Type=Integer,Description=\"DSCS-excluded SSCS depths on the forward and reverse read orientations for all alleles by sum. \">",
    "##FORMAT=<ID=cDPDf,Number=R,Type=Integer,Description=\"DSCS-excluded SSCS depth on the forward read orientation. \">",
    "##FORMAT=<ID=cDPDr,Number=R,Type=Integer,Description=\"DSCS-excluded SSCS depth on the reverse read orientation. \">",
    "##FORMAT=<ID=_DDP,Number=1,Type=String,Description=\"SUB-HEADER: Duplex consensus sequence (DCS, or double-strand consensus sequence (DSCS)) depths from the original double-stranded input molecule. \">",
    "##FORMAT=<ID=DDP1,Number=2,Type=Integer,Description=\"DCS depth regardless of allele agreement on the two strands for all alleles by sum and the padded deletion allele. \">",
    "##FORMAT=<ID=dDP1,Number=R,Type=Integer,Description=\"DCS depth regardless of allele agreement on the two strands for each allele. \">",
    "##FORMAT=<ID=DDP2,Number=2,Type=Integer,Description=\"DCS depth with allele agreement on the two strands for all alleles by sum and the padded deletion allele. \">",
    "##FORMAT=<ID=dDP2,Number=R,Type=Integer,Description=\"DCS depth with allele agreement on the two strands for each allele. \">",
    "##FORMAT=<ID=_ea,Number=1,Type=String,Description=\"SUB-HEADER: Error variables inferred from systematically low base-call qualities (BQs). \">",
    "##FORMAT=<ID=aBQ,Number=R,Type=Integer,Description=\"Root-mean-square base quality for sequencing segments. \">",
    "##FORMAT=<ID=a2BQf,Number=R,Type=Integer,Description=\"Summed squared/32 sequencing-segment base quality on the forward strand. \">",
    "##FORMAT=<ID=a2BQr,Number=R,Type=Integer,Description=\"Summed squared/32 sequencing-segment base quality on the reverse strand. \">",
    "##FORMAT=<ID=a2XM2,Number=R,Type=Integer,Description=\"Raw sequencing segment depth unaffected by absolute mismatch bias. \">",
    "##FORMAT=<ID=a2BM2,Number=R,Type=Integer,Description=\"Raw sequencing segment depth unaffected by absolute base-specific mismatch bias. \">",
    "##FORMAT=<ID=aBQQ,Number=R,Type=Integer,Description=\"Variant quality capped by systematic error inferred from base qualities. \">",
    "##FORMAT=<ID=_eb,Number=1,Type=String,Description=\"SUB-HEADER: Error variables inferred from systematically low mapping qualities (MAPQs or MQs). \">",
    "##FORMAT=<ID=bMQ,Number=R,Type=Integer,Description=\"Root-mean-square mapping quality for read fragments (max of R1 and R2 MQ is taken). \">",
    "##FORMAT=<ID=aAaMQ,Number=R,Type=Integer,Description=\"Read segment difference of average mapping quality between the ALT allele and the non-ALT alleles. \">",
    "##FORMAT=<ID=bNMQ,Number=R,Type=Integer,Description=\"Phred penalty inferred from high-BQ mismatches to the mapping quality (MAPQ). This penalty increases the MAPQ-related systematic error. \">",
    "##FORMAT=<ID=bNMa,Number=R,Type=Integer,Description=\"Percent of the number of fragment positions that are affected by nearby high-BQ mutation (by default, nearby means within one turn of DNA helix) for the ALT alleles. \">",
    "##FORMAT=<ID=bNMb,Number=R,Type=Integer,Description=\"Percent of the number of fragment positions that are affected by nearby high-BQ mutation (by default, nearby means within one turn of DNA helix) for all non-ALT alleles. \">",
    "##FORMAT=<ID=bMQQ,Number=R,Type=Integer,Description=\"Variant quality capped by systematic error inferred from mapping qualities. \">",
    "##FORMAT=<ID=_eB,Number=1,Type=String,Description=\"SUB-HEADER: Quality-related variables assuming IID read support (IID: independent and identically distributed) for duped reads. \">",
    "##FORMAT=<ID=bIAQb,Number=R,Type=Integer,Description=\"IID allele quality maximized with IAD and IDQ. \">",
    "##FORMAT=<ID=bIADb,Number=R,Type=Integer,Description=\"IID allele depth (number of reads supporting each ALT). \">",
    "##FORMAT=<ID=bIDQb,Number=R,Type=Integer,Description=\"IDD quality threshold per read support. \">",
    "##FORMAT=<ID=_eC,Number=1,Type=String,Description=\"SUB-HEADER: Quality-related variables assuming read supports are IID for de-duplicated reads. \">",
    "##FORMAT=<ID=cIAQf,Number=R,Type=Integer,Description=\"IID allele quality maximized with IAD and IDQ on the forward read orientation. \">",
    "##FORMAT=<ID=cIADf,Number=R,Type=Integer,Description=\"IID allele depth (number of reads supporting each ALT) on the forward read orientation. \">",
    "##FORMAT=<ID=cIDQf,Number=R,Type=Integer,Description=\"IDD quality threshold per read support on the forward read orientation. \">",
    "##FORMAT=<ID=cIAQr,Number=R,Type=Integer,Description=\"IID allele quality maximized with IAD and IDQ on the reverse read orientation. \">",
    "##FORMAT=<ID=cIADr,Number=R,Type=Integer,Description=\"IID allele depth (number of reads supporting each ALT) on the reverse read orientation. \">",
    "##FORMAT=<ID=cIDQr,Number=R,Type=Integer,Description=\"IDD quality threshold per read support on the reverse read orientation. \">",
    "##FORMAT=<ID=_eE,Number=1,Type=String,Description=\"SUB-HEADER: Binomial variant qualities. \">",
    "##FORMAT=<ID=bIAQ,Number=R,Type=Integer,Description=\"The duped fragment binomial variant quality by assuming statistical independence. \">",
    "##FORMAT=<ID=cIAQ,Number=R,Type=Integer,Description=\"The de-duplicated fragment binomial variant quality by assuming statistical independence. \">",
    "##FORMAT=<ID=bTINQ,Number=R,Type=Integer,Description=\"The fragment binomial tumor-in-normal quality by assuming statistical independence. \">",
    "##FORMAT=<ID=cTINQ,Number=R,Type=Integer,Description=\"The single-strand-consensus-sequence binomial tumor-in-normal quality by assuming statistical independence. \">",
    "##FORMAT=<ID=_eQ1,Number=1,Type=String,Description=\"SUB-HEADER: Power-law variant quality statistics for de-duplicated read fragments. \">",
    "##FORMAT=<ID=cPCQ1,Number=R,Type=Integer,Description=\"The de-duplicated read fragment power-law variant allele quality cap that is not lowered by using matched normal. \">",
    "##FORMAT=<ID=cPLQ1,Number=R,Type=Integer,Description=\"The de-duplicated read fragment power-law variant allele quality. \">",
    "##FORMAT=<ID=cVQ1,Number=R,Type=Integer,Description=\"The final variant quality computed with de-duplicated read fragments. \">",
    "##FORMAT=<ID=gVQ1,Number=R,Type=Integer,Description=\"The final variant quality computed with de-duplicated read fragments used for germline variant calls. \">",
    "##FORMAT=<ID=_eQ2,Number=1,Type=String,Description=\"SUB-HEADER: Power-law variant quality statistics for SSCS UMI-barcoded families. \">",
    "##FORMAT=<ID=cPCQ2,Number=R,Type=Integer,Description=\"The SSCS power-law variant allele quality cap that is not lowered by using matched normal. \">",
    "##FORMAT=<ID=cPLQ2,Number=R,Type=Integer,Description=\"The single-strand-consensus-sequence (SSCS) UMI-barcoded power-law variant allele quality. \">",
    "##FORMAT=<ID=cVQ2,Number=R,Type=Integer,Description=\"The final variant allele quality computed with SSCS UMI-barcoded families. \">",
    "##FORMAT=<ID=cMmQ,Number=R,Type=Integer,Description=\"The empirical base quality estimated with high-quality UMI barcode families. This field is defined to be the Phred-scaled fraction of minor read support to the sum of major and major read support, where major means agreement with UMI consensus, and minor means disagreement with UMI consensus. \">",
    "##FORMAT=<ID=dVQinc,Number=R,Type=Integer,Description=\"The increase in cVQ2 (excluding systematic error) contributed by double-strand-consensus-sequences (DSCSs) of duplex barcode famillies. Negative value means no increase. \">",
    "##FORMAT=<ID=_CDP1vx,Number=1,Type=String,Description=\"SUB-HEADER: Effective read support for de-duplicated fragments. \">",
    "##FORMAT=<ID=cDP1v,Number=R,Type=Integer,Description=\"The effective number of de-duplicated read fragments supporting each allele multiplied by 100 for within-sample comparison. \">",
    "##FORMAT=<ID=CDP1v,Number=2,Type=Integer,Description=\"The effective number of de-duplicated read fragments supporting all alleles multiplied by 100 for within-sample comparison. \">",
    "##FORMAT=<ID=cDP1w,Number=R,Type=Integer,Description=\"The effective number of de-duplicated read fragments supporting each allele multiplied by 100 for sample-specific variant-quality cap. \">",
    "##FORMAT=<ID=CDP1w,Number=1,Type=Integer,Description=\"The effective number of de-duplicated read fragments supporting all alleles multiplied by 100 for sample-specific variant-quality cap. \">",
    "##FORMAT=<ID=cDP1x,Number=R,Type=Integer,Description=\"The effective number of de-duplicated read fragments supporting each allele multiplied by 100 for between-sample comparison. \">",
    "##FORMAT=<ID=CDP1x,Number=1,Type=Integer,Description=\"The effective number of de-duplicated read fragments supporting all alleles multiplied by 100 \">",
    "##FORMAT=<ID=_CDP2vx,Number=1,Type=String,Description=\"SUB-HEADER: Effective read support for single-strand consensus sequence (SSCS) UMI-barcoded families. \">",
    "##FORMAT=<ID=cDP2v,Number=R,Type=Integer,Description=\"The effective number of SSCS UMI-barcoded families supporting each allele multiplied by 100 for within-sample comparison. \">",
    "##FORMAT=<ID=CDP2v,Number=2,Type=Integer,Description=\"The effective number of SSCS UMI-barcoded families supporting all alleles multiplied by 100 for within-sample comparison. \">",
    "##FORMAT=<ID=cDP2w,Number=R,Type=Integer,Description=\"The effective number of SSCS UMI-barcoded families supporting each allele multiplied by 100 for sample-specific variant-quality cap. \">",
    "##FORMAT=<ID=CDP2w,Number=1,Type=Integer,Description=\"The effective number of SSCS UMI-barcoded families supporting all alleles multiplied by 100 for sample-specific variant-quality cap. \">",
    "##FORMAT=<ID=cDP2x,Number=R,Type=Integer,Description=\"The effective number of SSCS UMI-barcoded families supporting each allele multiplied by 100 for between-sample comparison. \">",
    "##FORMAT=<ID=CDP2x,Number=1,Type=Integer,Description=\"The effective number of SSCS UMI-barcoded families supporting all alleles multiplied by 100 for between-sample comparison. \">",
    "##FORMAT=<ID=_f1,Number=1,Type=String,Description=\"SUB-HEADER: Filter-related information including counter-filters that rescue variants. \">",
    "##FORMAT=<ID=CONTQ,Number=R,Type=Integer,Description=\"Likelihood of the variant signal if the variant signal is contaminated. This value rescues variants in the matched normal control sample. \">",
    "##FORMAT=<ID=nPF,Number=.,Type=Integer,Description=\"Phred prior bias probability for base position and BAQ. \">",
    "##FORMAT=<ID=nNFA,Number=.,Type=Integer,Description=\"DeciPhred allele fractions computed using nullified bias (meaning that bias in ALT is countered by bias in REF). \">",
    "##FORMAT=<ID=nAFA,Number=.,Type=Integer,Description=\"DeciPhred allele fractions computed with sequencing-segment depths, reduced by none, left base position, base right position, left BAQ, right BAQ, left insert position, right insert position, strand, and passing-filter biases (8 biases), respectively. \">",
    "##FORMAT=<ID=nBCFA,Number=.,Type=Integer,Description=\"DeciPhred allele fractions computed with duped and de-duplicated depths, using duped depth, de-duplicated depth, tier-2 consensus family depth, tier-3 consensus family depth, tier-1 read-orientation depth, and tier-2 read-orientation depth, respectively. \">",
    "##FORMAT=<ID=_g1,Number=1,Type=String,Description=\"SUB-HEADER: General variant-related information. \">",
    "##FORMAT=<ID=VTI,Number=R,Type=Integer,Description=\"Variant-type ID of each allele. \">",
    "##FORMAT=<ID=VTD,Number=R,Type=String,Description=\"Variant-type description of each allele. \">",
    "##FORMAT=<ID=cVQ1M,Number=2,Type=Integer,Description=\"Consensus allele qualities for de-duplicated fragments and UMI families. \">",
    "##FORMAT=<ID=cVQ2M,Number=2,Type=Integer,Description=\"Consensus allele qualities for de-duplicated fragments and UMI families. \">",
    "##FORMAT=<ID=cVQAM,Number=2,Type=String,Description=\"Consensus allele symbolic descriptions for de-duplicated fragments and UMI families. \">",
    "##FORMAT=<ID=cVQSM,Number=2,Type=String,Description=\"Consensus allele InDel strings for de-duplicated fragments and UMI families. \">",
    "##FORMAT=<ID=_g2,Number=1,Type=String,Description=\"SUB-HEADER: Gap-related information for all observed InDel signals. \">",
    "##FORMAT=<ID=gapNf,Number=.,Type=Integer,Description=\"Number of InDel sequences on the forward read orientation. \">",
    "##FORMAT=<ID=gapNr,Number=.,Type=Integer,Description=\"Number of InDel sequences on the reverse read orientation. \">",
    "##FORMAT=<ID=gapSeq,Number=.,Type=String,Description=\"InDel sequences. \">",
    "##FORMAT=<ID=gapbAD1,Number=.,Type=Integer,Description=\"Duped read count of each gapSeq. \">",
    "##FORMAT=<ID=gapcAD1,Number=.,Type=Integer,Description=\"De-duplicated read count of each gapSeq. \">",
    "##FORMAT=<ID=gc2AD,Number=.,Type=Integer,Description=\"De-duplicated read count of each gapSeq using tier-2 consensus (by default, 0.8 is the consensus allele proportion in family and 2 is the family size). \">",
    "##FORMAT=<ID=gc2dAD,Number=.,Type=Integer,Description=\"De-duplicated read count of each gapSeq using tier-2 consensus with rescue by duplex consensus sequence (DCS) or double-strand consensus sequence (DSC), meaning that alpha-beta singleton and beta-alpha singleton are counted as two units of evidence in support of the allele instead of being rejected. \">",
    "##FORMAT=<ID=_g3,Number=1,Type=String,Description=\"SUB-HEADER: Gap-related information for each InDel allele. \">",
    "##FORMAT=<ID=bDPa,Number=R,Type=Integer,Description=\"Number of non-de-duplicated fragments supporting each ALT allele which is more precise for InDels. \">",
    "##FORMAT=<ID=cDP0a,Number=R,Type=Integer,Description=\"Number of de-duplicated fragments supporting each ALT allele which is more precise for InDels. \">",
    "##FORMAT=<ID=gapSa,Number=R,Type=String,Description=\"InDel string of each allele. \">",
    "##FORMAT=<ID=_h1,Number=1,Type=String,Description=\"SUB-HEADER: Haplotype-related information. \">",
    "##FORMAT=<ID=bHap,Number=1,Type=String,Description=\"Duped forward&reverse linkage in the format of ((position&variantType)...forwardHAD&reverseHAD[forwardTotalHAD,reverseTotalHAD])... where HAD is the haplotype allele depth and where ()... means more elements following the format in the preceding parenthesis. \">",
    "##FORMAT=<ID=cHap,Number=1,Type=String,Description=\"Same as bHap except that duplicated reads are counted only once (dedupped). \">",
    "##FORMAT=<ID=c2Hap,Number=1,Type=String,Description=\"Same as cHap except that reads are grouped into UMI barcode families using tier-2 consensus. \">",
    "##FORMAT=<ID=_i1,Number=1,Type=String,Description=\"SUB-HEADER: Other information. \">",
    "##FORMAT=<ID=vHGQ,Number=1,Type=Integer,Description=\"Phred-scaled odds of observing the allele distribution at this genomic position assuming all alleles were generated by germline events (higher means less likely). \">",
    "##FORMAT=<ID=vAC,Number=2,Type=Integer,Description=\"Number of SNVs and InDels that passed their variant quality thresholds at this position. This field can be used to filter out multiallelic variants or to merge alleles at the same position. \">",
    "##FORMAT=<ID=vNLODQ,Number=2,Type=Integer,Description=\"Number of SNVs and InDels that passed their variant quality thresholds at this position. This field can be used to filter out SNV-in-tumor with InDel-in-normal or InDel-in-tumor with SNV-in-normal at the same position. \">",
    "##FORMAT=<ID=note,Number=1,Type=String,Description=\"Additional note as comment for the given variant. \">",
};
};
#endif
