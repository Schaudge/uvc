#include <stdint.h>
#include <stdio.h>  
#include <stdlib.h>
#include <string.h>

#include "unistd.h"
#include "zlib.h"

#include "htslib/kseq.h"

#include "version.h"

#define MAX_UMI_LEN (128)

KSEQ_INIT(gzFile, gzread)

typedef struct {
    char *in[2];
    char *out[2];
    unsigned int beg[2];
    unsigned int end[2];
    unsigned int isduplex;
    unsigned int use_comment_as_header;
} CmdLineArgs;

void usage(int argc, char **argv) {
    const char *requiredhelp = "\n\tThis parameter is required.";
    const char *sehelp = "\n\tLeave this parameter empty if the input data is single-end.";
    const char *zerohelp = "\n\tThis parameter has a default value of zero and is of positive-integer type.";

    fprintf(stderr, "Proram %s version %s\n", argv[0], VERSION_DETAIL);
    fprintf(stderr, "  -h\tShow this help message\n");
    fprintf(stderr, "  -v\tShow the version information\n");
    
    fprintf(stderr, "  -i\tThe R1 input gzipped fastq filename of string type.%s\n", requiredhelp);
    fprintf(stderr, "  -o\tThe R1 output gzipped fastq filename of string type.%s\n", requiredhelp);
    fprintf(stderr, "  -b\tThe inclusive begin position of the UMI in the R1 input gzipped fastq filename.%s\n", zerohelp);
    fprintf(stderr, "  -e\tThe exclusive end position of the UMI in the R1 input gzipped fastq filename.%s\n", zerohelp);
    
    fprintf(stderr, "  -j\tThe R2 input gzipped fastq filename of string type.%s\n", sehelp);
    fprintf(stderr, "  -p\tThe R2 output gzipped fastq filename of string type.%s\n", sehelp);
    fprintf(stderr, "  -c\tThe inclusive begin position of the UMI in the R2 input gzipped fastq filename.%s\n", zerohelp);
    fprintf(stderr, "  -f\tThe exclusive end position of the UMI in the R1 input gzipped fastq filename.%s\n", zerohelp);
    
    fprintf(stderr, "  -C\tIf this switch is turned on, then use the first whitespace-separated token in the comment as sequence name.\n");
    fprintf(stderr, "  -D\tIf this switch is turned on, then assume that the input data is generated by duplex sequencing, and vice versa.\n");
}

int parse(CmdLineArgs *args_ptr, int argc, char **argv) {
    int opt; 
    while ((opt = getopt(argc, argv, "b:c:e:f:i:j:o:p:CDvh")) != -1) {
        switch(opt) {
            case 'b': args_ptr->beg[0] = atoi(optarg); /* printf("beg0 = %d\n", args_ptr->beg[0]); */ break;
            case 'c': args_ptr->beg[1] = atoi(optarg); /* printf("beg1 = %d\n", args_ptr->beg[1]); */ break;
            case 'e': args_ptr->end[0] = atoi(optarg); /* printf("end0 = %d\n", args_ptr->end[0]); */ break;
            case 'f': args_ptr->end[1] = atoi(optarg); /* printf("end1 = %d\n", args_ptr->end[1]); */ break;
            case 'i': args_ptr->in[0]  = optarg; break;
            case 'j': args_ptr->in[1]  = optarg; break;
            case 'o': args_ptr->out[0] = optarg; break;
            case 'p': args_ptr->out[1] = optarg; break;
            case 'C': args_ptr->use_comment_as_header = 1; break;
            case 'D': args_ptr->isduplex = 1; break;
            case 'v': fprintf(stderr, "Program %s version %s\n", argv[0], VERSION_DETAIL); return 0;
            case 'h': usage(argc, argv); exit(0);
            default:  usage(argc, argv); return -1;
        }
    }
    return 0;
}

int process(const CmdLineArgs args, const unsigned int r1r2num) {
    int ret = 0;

    char umis[2][MAX_UMI_LEN];
    gzFile in[2];
    kseq_t *seq[2] = {NULL, NULL};
    gzFile out[2]; 
    
    for (unsigned int r1r2idx = 0; r1r2idx < r1r2num; r1r2idx++) { 
        memset(umis[r1r2idx], 0, MAX_UMI_LEN); 
        in[r1r2idx]  = gzopen(args.in[r1r2idx],  "r"); 
        seq[r1r2idx] = kseq_init(in[r1r2idx]);
        out[r1r2idx] = gzopen(args.out[r1r2idx], "wb1");
    }
    
    int lens[2] = {0, 0};
    for (uint64_t nrec = 1;; nrec++) {
        for (unsigned int r1r2idx = 0; r1r2idx < r1r2num; r1r2idx++) {
            unsigned int beg = args.beg[r1r2idx];
            unsigned int end = args.end[r1r2idx];
            lens[r1r2idx] = kseq_read(seq[r1r2idx]);
            if (end > beg) {
                if (seq[r1r2idx]->seq.l > end) {
                    strncpy(umis[r1r2idx], &(seq[r1r2idx]->seq.s[beg]), end-beg);
                } else {
                    for (unsigned int posidx = 0; posidx < end - beg; posidx++) {
                        umis[r1r2idx][posidx] = 'N';
                    }
                }
            } else {
                umis[r1r2idx][0] = '\0';
            }
        }
        if (lens[0] < 0 || lens[1] < 0) {
            break;
        }
        for (unsigned int r1r2idx = 0; r1r2idx < r1r2num; r1r2idx++) {
            gzwrite(out[r1r2idx], "@", 1);
            if (args.use_comment_as_header) {
                unsigned int hdrlen = 0;
                for (; seq[r1r2idx]->comment.s[hdrlen] > ' '; hdrlen++);
                gzwrite(out[r1r2idx], seq[r1r2idx]->comment.s, hdrlen);
            } else { 
                gzwrite(out[r1r2idx], seq[r1r2idx]->name.s, seq[r1r2idx]->name.l);
            }
            gzwrite(out[r1r2idx], "#", 1);
            unsigned int umi_num = 0;
            for (unsigned int r1r2idx2 = 0; r1r2idx2 < r1r2num; r1r2idx2++) {
                if (umis[r1r2idx2][0] != '\0') {
                    if (umi_num > 0) { 
                        gzwrite(out[r1r2idx], (args.isduplex ? "+" : "-"), 1);
                    }
                    gzwrite(out[r1r2idx], umis[r1r2idx2], strlen(umis[r1r2idx2]));
                    umi_num++;
                }
            }
            gzwrite(out[r1r2idx], "\n", 1);
            gzwrite(out[r1r2idx], seq[r1r2idx]->seq.s, seq[r1r2idx]->seq.l);
            gzwrite(out[r1r2idx], "\n", 1);
            gzwrite(out[r1r2idx], "+", 1);
            gzwrite(out[r1r2idx], seq[r1r2idx]->name.s, seq[r1r2idx]->name.l);
            gzwrite(out[r1r2idx], " ", 1);
            gzwrite(out[r1r2idx], seq[r1r2idx]->comment.s, seq[r1r2idx]->comment.l);
            gzwrite(out[r1r2idx], "\n", 1);
            gzwrite(out[r1r2idx], seq[r1r2idx]->qual.s, seq[r1r2idx]->qual.l);
            gzwrite(out[r1r2idx], "\n", 1);
        }
    }
    
    for (unsigned int r1r2idx = 0; r1r2idx < r1r2num; r1r2idx++) { 
        gzclose(out[r1r2idx]);
        kseq_destroy(seq[r1r2idx]);
        gzclose(in[r1r2idx]);
        if (lens[r1r2idx] != lens[0]) {
            fprintf(stderr, "Warning: last kseq_read return codes for R1 and R%d are %d and %d, implying R1 and R%d may have different number of records.\n", 
                    r1r2idx+1, lens[0], lens[r1r2idx], r1r2idx+1);
            ret -= 2;
        }
    }
    return ret;
}

int main(int argc, char **argv) {
    CmdLineArgs args;
    memset(&args, 0, sizeof(args));
    
    int parse_res = parse(&args, argc, argv);
    if (parse_res != 0) { return parse_res; }
    
    if (NULL == args.in[0] || NULL == args.out[0]) {
        fprintf(stderr, "The R1 end must have both input gzipped FASTQ file and output gzipped FASTQ file.\n");
        usage(argc, argv);
        return 1;
    }
    if (args.end[0] - args.beg[0] >= MAX_UMI_LEN) {
        fprintf(stderr, "The R1 end of input gzipped FASTQ file has UMI of length (%d-%d), but the maximum allowed UMI length is %d.\n", args.end[0], args.beg[0], MAX_UMI_LEN-1);
        usage(argc, argv);
        return 4;
    }
    
    unsigned int r1r2num = 1;
    if (NULL != args.in[1] || NULL != args.out[1]) {
        if (NULL == args.in[1] || NULL == args.out[1]) {
            fprintf(stderr, "The R2 end must have both input gzipped FASTQ file and output gzipped FASTQ file.\n");
            usage(argc, argv);
            return 2;
        }
        if (args.end[1] - args.beg[1] >= MAX_UMI_LEN) {
            fprintf(stderr, "The R2 end of input gzipped FASTQ file has UMI of length (%d-%d), but the maximum allowed UMI length is %d.\n", args.end[1], args.beg[1], MAX_UMI_LEN-1);
            usage(argc, argv);
            return 8;
        }
        r1r2num = 2;
    }

    return process(args, r1r2num);
}
